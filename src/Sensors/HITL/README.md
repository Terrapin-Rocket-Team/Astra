# Hardware-In-The-Loop (HITL) Framework

The HITL framework enables testing flight computer software with desktop simulations. Instead of reading from physical sensors, HITL sensors receive simulated data over USB Serial, allowing you to iterate rapidly on algorithms without deploying to hardware.

## Architecture

```
┌─────────────────────────────────┐
│   Desktop Simulation            │
│   (Python, MATLAB, etc.)        │
└────────────┬────────────────────┘
             │ USB Serial
             │ "HITL/" packets ↓
             │ "TELEM/" packets ↑
┌────────────▼────────────────────┐
│   Flight Computer (Hardware)    │
│                                  │
│   HITLParser ──→ HITLSensorBuffer│
│        │              │          │
│        ▼              ▼          │
│   Astra System    HITL Sensors   │
│   update(simTime)    │           │
│        │              │          │
│        ▼              ▼          │
│   RocketState    DataLogger      │
│        │              │          │
│        └──────┬───────┘          │
│               ▼                  │
│        "TELEM/" output           │
└──────────────────────────────────┘
```

## Components

### HITLSensorBuffer
Singleton buffer that stores the current simulation timestep's sensor data. All HITL sensors read from this shared buffer.

### HITL Sensors
- **HITLBarometer** - Simulated barometer (pressure, temperature, altitude)
- **HITLAccel** - Simulated accelerometer
- **HITLGyro** - Simulated gyroscope
- **HITLMag** - Simulated magnetometer
- **HITLGPS** - Simulated GPS

Each implements the standard sensor interface, so they're drop-in replacements for hardware sensors.

### HITLParser
Parses incoming `HITL/` messages and populates the HITLSensorBuffer.

## Protocol

### Input (Desktop → Hardware)
Format: `HITL/timestamp,ax,ay,az,gx,gy,gz,mx,my,mz,pressure,temp,lat,lon,alt,fix,fixqual,heading\n`

Example:
```
HITL/1.234,0.0,0.0,9.81,0.0,0.0,0.0,20.0,10.0,-45.0,1013.25,25.0,45.123,-122.456,100.0,1,8,90.0
```

Fields:
- `timestamp` - Simulation time (s)
- `ax,ay,az` - Acceleration (m/s²)
- `gx,gy,gz` - Angular velocity (rad/s)
- `mx,my,mz` - Magnetic field (µT)
- `pressure` - Pressure (hPa / mbar)
- `temp` - Temperature (°C)
- `lat,lon` - GPS coordinates (decimal degrees)
- `alt` - GPS altitude MSL (m)
- `fix` - GPS fix status (0=no fix, 1=has fix)
- `fixqual` - GPS fix quality (number of satellites)
- `heading` - GPS heading (degrees)

### Output (Hardware → Desktop)
Automatically generated by DataLogger with `TELEM/` prefix:

```
TELEM/RocketState - Flight Stage,RocketState - Altitude AGL,...
TELEM/1,123.45,...
```

The desktop simulation parses these lines to extract state information.

## Usage

### Method 1: With SerialMessageRouter (Recommended)

This is the modern, clean approach that integrates with the centralized serial routing system.

#### 1. Include Headers
```cpp
#include <Sensors/HITL/HITL.h>
#include <Communication/SerialMessageRouter.h>

using namespace astra;
```

#### 2. Create HITL Sensors
```cpp
// Instead of hardware sensors:
// DPS368* baro = new DPS368(&Wire, 0x77);

// Use HITL sensors:
HITLBarometer* baro = new HITLBarometer();
HITLAccel* accel = new HITLAccel();
HITLGyro* gyro = new HITLGyro();
HITLMag* mag = new HITLMag();
HITLGPS* gps = new HITLGPS();

// Build sensor array as usual
Sensor* sensors[] = {baro, accel, gyro, mag, gps};
```

#### 3. Setup SerialMessageRouter
```cpp
SerialMessageRouter router;
Astra* astraSys;  // Your Astra system instance

void handleHITL(const char* message, const char* prefix, Stream* source) {
    double simTime;
    if (HITLParser::parse(message, simTime)) {
        // Update with simulation time (NOT millis()!)
        astraSys->update(simTime);
        // DataLogger automatically outputs "TELEM/" data
    } else {
        LOGE("HITL: Failed to parse packet");
    }
}

void setup() {
    Serial.begin(115200);

    // Initialize your Astra system...
    // astraSys = new Astra(&config);

    // Configure router to handle HITL messages
    router.withInterface(&Serial)
          .withListener("HITL/", handleHITL);
}
```

#### 4. Main Loop
```cpp
void loop() {
    router.update();  // Automatically handles HITL/ messages

    // Rest of your code...
}
```

If you are using the full `Astra` system, you can register the listener on
`Astra::getMessageRouter()` and skip calling `router.update()` manually.

**Benefits:**
- Clean separation of concerns
- Easy to add other message types (CMD/, RAD/, etc.)
- Automatic prefix handling
- Works with multiple serial interfaces simultaneously

---

### Method 2: Manual Parsing (Legacy)

This is the original approach without SerialMessageRouter.

#### 1. Include HITL Header
```cpp
#include <Sensors/HITL/HITL.h>
```

#### 2. Create HITL Sensors
```cpp
HITLBarometer* baro = new HITLBarometer();
HITLAccel* accel = new HITLAccel();
HITLGyro* gyro = new HITLGyro();
HITLMag* mag = new HITLMag();
HITLGPS* gps = new HITLGPS();

Sensor* sensors[] = {baro, accel, gyro, mag, gps};
```

#### 3. Main Loop
```cpp
void loop() {
    // Check for HITL data
    if (Serial.available()) {
        String line = Serial.readStringUntil('\n');

        if (line.startsWith("HITL/")) {
            // Parse incoming sensor data
            double simTime;
            if (HITLParser::parseAndInject(line.c_str(), simTime)) {
                // Update with simulation time (NOT millis()!)
                astraSys->update(simTime);

                // DataLogger automatically outputs "TELEM/" data
            } else {
                LOGE("HITL: Failed to parse packet");
            }
        }
    }
}
```

---

### 4. Desktop Simulation Side
```python
import serial
import time

ser = serial.Serial('/dev/ttyACM0', 115200)

# Simulation loop
sim_time = 0.0
dt = 0.02  # 50 Hz

while sim_time < 10.0:
    # Generate or compute sensor data
    ax, ay, az = compute_acceleration(sim_time)
    gx, gy, gz = compute_angular_velocity(sim_time)
    mx, my, mz = compute_magnetic_field(sim_time)
    pressure = compute_pressure(sim_time)
    temp = 25.0
    lat, lon, alt = compute_gps_position(sim_time)
    fix, fixqual, heading = 1, 8, 90.0

    # Send HITL packet
    packet = f"HITL/{sim_time},{ax},{ay},{az},{gx},{gy},{gz},"
    packet += f"{mx},{my},{mz},{pressure},{temp},"
    packet += f"{lat},{lon},{alt},{fix},{fixqual},{heading}\n"
    ser.write(packet.encode())

    # Read TELEM response
    line = ser.readline().decode().strip()
    if line.startswith("TELEM/"):
        # Parse state output
        state = parse_telem_line(line)
        update_simulation(state)

    sim_time += dt
```

## Benefits

✅ **Rapid iteration** - Test algorithms without deploying to hardware
✅ **Deterministic** - Same inputs produce same outputs
✅ **Safe** - No risk of damaging hardware during testing
✅ **Complete system test** - Exercises the full flight computer stack
✅ **Reuses telemetry** - Leverages existing DataLogger infrastructure
✅ **Drop-in replacement** - HITL sensors use standard interfaces

## Notes

- HITL mode is blocking - the hardware waits for each `HITL/` message before processing
- Use simulation time, not `millis()` - call `astraSys->update(simTime)` explicitly
- DataLogger automatically handles `TELEM/` output - no extra code needed
- All HITL sensors are header-only - no linking required
- Compatible with existing Kalman filters, state estimation, etc.

## Example Projects

See `examples/HITLExample/` for a complete working example.

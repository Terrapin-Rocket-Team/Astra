{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Astra Documentation","text":"<p>Astra is the Terrapin Rocket Team's modular flight software library for embedded systems. It provides sensor abstraction, state estimation, logging, and testing utilities so you can focus on mission logic instead of plumbing.</p>"},{"location":"#what-astra-gives-you","title":"What Astra Gives You","text":"<ul> <li>Drop-in sensor stack: IMU, GPS, barometer, magnetometer, voltage, and HITL sensors</li> <li>State estimation: Orientation (Mahony AHRS) + position/velocity (Kalman filter)</li> <li>Unified logging: CSV telemetry (<code>DataLogger</code>) and event logs (<code>EventLogger</code>)</li> <li>Multi-platform: STM32, Teensy, ESP32, plus native SITL builds</li> <li>Testing &amp; simulation: HITL parser, SerialMessageRouter, SITL example</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Read Installation</li> <li>Follow Basic Usage</li> <li>Dive deeper via the User Guide and Interfaces sections</li> </ol>"},{"location":"#core-architecture","title":"Core Architecture","text":"<p>Astra System - <code>Astra</code> orchestrates sensors, state updates, and telemetry logging - <code>AstraConfig</code> wires sensors, log sinks, status LEDs, and HITL mode</p> <p>Sensors - Sensors are <code>DataReporter</code>s (auto-registered for logging) - <code>Astra</code> updates sensors on their own rates and uses the latest healthy data</p> <p>State Estimation - <code>State</code> is math-only: it consumes vectors and outputs position/velocity/orientation - <code>DefaultState</code> provides a ready-to-use filter stack</p> <p>Logging - <code>DataLogger</code> emits CSV telemetry (<code>TELEM/</code> prefix when enabled) - <code>EventLogger</code> emits human-readable logs (<code>LOG/</code> prefix when enabled)</p> <p>Serial &amp; Simulation - <code>SerialMessageRouter</code> routes prefixed messages (e.g., <code>HITL/</code>, <code>CMD/</code>) - HITL/SITL sensors allow full-system testing without hardware</p>"},{"location":"#where-to-go-next","title":"Where To Go Next","text":"<ul> <li>Installation</li> <li>Basic Usage</li> <li>Astra System</li> <li>Sensors &amp; Interfaces</li> </ul>"},{"location":"maintainer-guide/","title":"Maintainer Guide","text":"<p>This section is for contributors maintaining Astra.</p>"},{"location":"maintainer-guide/#documentation-workflow","title":"Documentation Workflow","text":"<p>Docs are powered by MkDocs + Material.</p> <pre><code>mkdocs serve\n</code></pre> <p>Edit pages under <code>docs/docs/</code>, then verify locally.</p>"},{"location":"maintainer-guide/#versioning","title":"Versioning","text":"<p>When you cut a release:</p> <ol> <li>Update <code>library.json</code> version</li> <li>Update <code>docs/mkdocs.yml</code> <code>repo_version</code></li> <li>Tag the release in Git</li> </ol>"},{"location":"maintainer-guide/#adding-a-sensor","title":"Adding a Sensor","text":"<ol> <li>Create a class derived from the appropriate base (<code>Accel</code>, <code>Gyro</code>, <code>Barometer</code>, etc.)</li> <li>Implement <code>init()</code> and <code>read()</code> (return 0 on success)</li> <li>Register telemetry columns in the constructor</li> <li>Add documentation in <code>docs/docs/user-guide/ifaces/sensors/</code></li> </ol>"},{"location":"maintainer-guide/#logging-integration","title":"Logging Integration","text":"<ul> <li>Sensors and State auto\u2011register via <code>DataReporter</code></li> <li><code>EventLogger::configure()</code> must be called to emit logs</li> </ul>"},{"location":"maintainer-guide/#internal-apis","title":"Internal APIs","text":"<ul> <li>SensorManager (Internal)</li> </ul>"},{"location":"maintainer-guide/#tests","title":"Tests","text":"<p>Tests are under <code>test/</code> and run with PlatformIO:</p> <pre><code>pio test -e native\n</code></pre>"},{"location":"maintainer-guide/#style-notes","title":"Style Notes","text":"<ul> <li>Avoid dynamic allocation in hot paths</li> <li>Prefer <code>Vector</code>/<code>Matrix</code> over ad\u2011hoc math</li> <li>Keep sensor updates non\u2011blocking</li> </ul>"},{"location":"maintainer-guide/sensor-manager/","title":"SensorManager (Internal)","text":"<p><code>SensorManager</code> owns the active sensor set and provides access to sensor data and update flags. It is an internal utility used by <code>Astra</code> and <code>AstraConfig</code>.</p>"},{"location":"maintainer-guide/sensor-manager/#responsibilities","title":"Responsibilities","text":"<ul> <li>Calls <code>begin()</code> on each configured sensor</li> <li>Updates sensors based on <code>shouldUpdate()</code></li> <li>Tracks which sensors produced new data this cycle</li> <li>Tracks init failures and health status</li> </ul>"},{"location":"maintainer-guide/sensor-manager/#key-methods","title":"Key Methods","text":"<pre><code>void update(double currentTime);\n\nbool hasAccelUpdate() const;\nbool hasGyroUpdate() const;\nbool hasBaroUpdate() const;\nbool hasGPSUpdate() const;\n\nVector&lt;3&gt; getAcceleration() const;\nVector&lt;3&gt; getAngularVelocity() const;\ndouble getBarometricAltitude() const;\nVector&lt;3&gt; getGPSPosition() const;\nVector&lt;3&gt; getGPSVelocity() const;\n</code></pre>"},{"location":"maintainer-guide/sensor-manager/#typical-usage","title":"Typical Usage","text":"<p>Most users should not interact with <code>SensorManager</code> directly; <code>Astra</code> manages it internally.</p> <p>If you need direct access (custom loop or testing), instantiate and populate it manually in your own code or tests.</p>"},{"location":"user-guide/basic-use/","title":"Basic Usage","text":"<p>This guide shows the current (v0.2+) Astra workflow:</p> <ol> <li>Instantiate sensors</li> <li>Create a <code>State</code> (usually <code>DefaultState</code>) or let Astra create one for you</li> <li>Configure logging sinks</li> <li>Build <code>AstraConfig</code> with sensors and state</li> <li>Call <code>init()</code> and <code>update()</code></li> </ol>"},{"location":"user-guide/basic-use/#1-create-sensors","title":"1. Create Sensors","text":"src/main.cpp<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;Utils/Astra.h&gt;\n#include &lt;State/DefaultState.h&gt;\n\n#include &lt;Sensors/HW/IMU/BMI088.h&gt;\n#include &lt;Sensors/HW/Baro/DPS368.h&gt;\n#include &lt;Sensors/HW/GPS/MAX_M10S.h&gt;\n\nusing namespace astra;\n\nBMI088 imu;\nDPS368 baro;\nMAX_M10S gps;\n</code></pre> <p>If you use a 9-DoF IMU (e.g. BNO055), use <code>with9DoFIMU()</code> later.</p>"},{"location":"user-guide/basic-use/#2-create-a-state","title":"2. Create a State","text":"<p>For most projects, start with <code>DefaultState</code>:</p> <pre><code>DefaultState state;\n</code></pre> <p>If you want full control, you can pass your own filters to <code>State</code>:</p> <pre><code>#include &lt;Filters/DefaultKalmanFilter.h&gt;\n#include &lt;Filters/Mahony.h&gt;\n\nDefaultKalmanFilter kf;\nMahonyAHRS ahrs;\nState state(&amp;kf, &amp;ahrs);\n</code></pre>"},{"location":"user-guide/basic-use/#3-configure-logging-optional-but-recommended","title":"3. Configure Logging (Optional but Recommended)","text":"<p>Event logs are configured separately from telemetry logs. You can either call <code>EventLogger::configure()</code> yourself or pass sinks to <code>withEventLogs()</code>.</p> <pre><code>#include &lt;RecordData/Logging/EventLogger.h&gt;\n#include &lt;RecordData/Logging/LoggingBackend/ILogSink.h&gt;\n\nUARTLog eventLog(Serial, 115200, true);\nILogSink* eventSinks[] = { &amp;eventLog };\n\n// Option A: configure manually\n// EventLogger::configure(eventSinks, 1);\n</code></pre> <p>Telemetry logs (CSV) are configured via <code>AstraConfig</code>:</p> <pre><code>#include &lt;RecordData/Logging/LoggingBackend/ILogSink.h&gt;\n\nFileLogSink telemFile(\"TELEM.csv\", StorageBackend::SD_CARD, true);\nILogSink* telemSinks[] = { &amp;telemFile };\n</code></pre>"},{"location":"user-guide/basic-use/#4-build-astraconfig","title":"4. Build <code>AstraConfig</code>","text":"<pre><code>AstraConfig config = AstraConfig()\n    .with6DoFIMU(&amp;imu)\n    .withBaro(&amp;baro)\n    .withGPS(&amp;gps)\n    .withState(&amp;state)           // Optional if you want DefaultState automatically\n    .withBBPin(LED_BUILTIN)\n    .withBuzzerPin(13)\n    .withDataLogs(telemSinks, 1)\n    .withEventLogs(eventSinks, 1);\n</code></pre> <p>If you have a separate magnetometer:</p> <pre><code>#include &lt;Sensors/HW/Mag/MMC5603NJ.h&gt;\n\nMMC5603NJ mag;\n\nconfig.withMag(&amp;mag);\n</code></pre>"},{"location":"user-guide/basic-use/#5-initialize-and-update","title":"5. Initialize and Update","text":"<pre><code>Astra sys(&amp;config);\n\nvoid setup() {\n    Serial.begin(115200);\n    int err = sys.init();\n    if (err != 0) {\n        LOGE(\"Astra init failed with %d error(s)\", err);\n    }\n}\n\nvoid loop() {\n    sys.update();  // Uses millis() internally\n}\n</code></pre>"},{"location":"user-guide/basic-use/#6-access-state-data","title":"6. Access State Data","text":"<pre><code>Vector&lt;3&gt; pos = state.getPosition();\nVector&lt;3&gt; vel = state.getVelocity();\nQuaternion att = state.getOrientation();\n</code></pre>"},{"location":"user-guide/basic-use/#sensor-update-rates","title":"Sensor Update Rates","text":"<p>There is no global update rate. Each sensor controls its own rate:</p> <pre><code>imu.setUpdateRate(100);  // 100 Hz\nbaro.setUpdateRate(20);  // 20 Hz\ngps.setUpdateRate(5);    // 5 Hz\n</code></pre> <p><code>Astra::update()</code> can run as fast as your loop; sensors decide when to read.</p>"},{"location":"user-guide/basic-use/#common-patterns","title":"Common Patterns","text":"<ul> <li>IMU-only orientation: <code>with6DoFIMU()</code> + <code>DefaultState</code> gives fast attitude estimation.</li> <li>Baro + GPS fusion: add <code>withBaro()</code> and <code>withGPS()</code> for position/velocity corrections.</li> <li>Extra sensors for logging: use <code>withMiscSensor()</code> to log custom sensors without feeding State.</li> </ul>"},{"location":"user-guide/basic-use/#command-system-serialmessagerouter","title":"Command System (SerialMessageRouter)","text":"<p><code>Astra</code> creates a <code>SerialMessageRouter</code> internally and listens for:</p> <pre><code>CMD/HEADER\n</code></pre> <p>Sending <code>CMD/HEADER</code> on a serial interface prints the current telemetry header to that stream.</p> <p>Add your own commands via <code>getMessageRouter()</code>:</p> <pre><code>SerialMessageRouter* router = sys.getMessageRouter();\nrouter-&gt;withListener(\"CMD/\", myHandler);\n</code></pre> <p>For more details, see SerialMessageRouter.</p>"},{"location":"user-guide/basic-use/#next-steps","title":"Next Steps","text":"<ul> <li>Astra System</li> <li>Logging</li> <li>State</li> <li>Sensor Interface</li> </ul>"},{"location":"user-guide/faq/","title":"FAQ","text":""},{"location":"user-guide/faq/#what-coordinate-frame-does-state-use","title":"What coordinate frame does State use?","text":"<p><code>State</code> uses ENU (East, North, Up). If you see references to NEU in older docs, that is a documentation error.</p>"},{"location":"user-guide/faq/#does-the-imu-provide-orientation","title":"Does the IMU provide orientation?","text":"<p>No. IMU classes return raw sensor data only. Orientation is estimated by <code>MahonyAHRS</code> inside <code>State</code>.</p>"},{"location":"user-guide/faq/#can-i-reconfigure-logging-after-init","title":"Can I reconfigure logging after init?","text":"<p>Yes. You can call:</p> <pre><code>EventLogger::configure(eventSinks, count);\nDataLogger::configure(dataSinks, count);\n</code></pre> <p>This is useful if a sink becomes available later (e.g., USB or radio connection).</p>"},{"location":"user-guide/faq/#do-i-need-to-call-serialmessagerouterupdate","title":"Do I need to call <code>SerialMessageRouter::update()</code>?","text":"<p>Only if you are using it standalone. If you use the full Astra system, it updates the router internally.</p>"},{"location":"user-guide/hitl/","title":"HITL (Hardware\u2011In\u2011The\u2011Loop)","text":"<p>HITL lets you run Astra against simulated sensor data over a serial link.</p>"},{"location":"user-guide/hitl/#data-flow","title":"Data Flow","text":"<pre><code>Simulator \u2192 HITL/ lines \u2192 HITLParser \u2192 HITLSensorBuffer \u2192 HITL Sensors \u2192 Astra\n</code></pre>"},{"location":"user-guide/hitl/#message-format","title":"Message Format","text":"<pre><code>HITL/timestamp,ax,ay,az,gx,gy,gz,mx,my,mz,pressure,temp,lat,lon,alt,fix,fixqual,heading\n</code></pre> <p>Units:</p> <ul> <li>Accel: m/s\u00b2</li> <li>Gyro: rad/s</li> <li>Mag: \u00b5T</li> <li>Pressure: hPa</li> <li>Temp: \u00b0C</li> <li>GPS lat/lon: degrees</li> <li>GPS alt: meters</li> </ul>"},{"location":"user-guide/hitl/#router-integration-recommended","title":"Router Integration (Recommended)","text":"<pre><code>auto* router = sys.getMessageRouter();\nrouter-&gt;withListener(\"HITL/\", [](const char* msg, const char* prefix, Stream* src) {\n    double simTime;\n    if (HITLParser::parse(msg, simTime)) {\n        sys.update(simTime);\n    }\n});\n</code></pre> <p>Because Astra already updates its router, you do not need to call <code>router-&gt;update()</code> manually.</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>This guide assumes you are using PlatformIO with the Arduino framework.</p>"},{"location":"user-guide/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>VS Code + PlatformIO extension</li> <li>A supported board (Teensy, STM32, ESP32)</li> <li>Basic C++ familiarity</li> </ul>"},{"location":"user-guide/installation/#add-astra-to-platformioini","title":"Add Astra to <code>platformio.ini</code>","text":"<p>Create a new PlatformIO project and add Astra to <code>lib_deps</code>.</p> platformio.ini<pre><code>[env:teensy41]\nplatform = teensy\nboard = teensy41\nframework = arduino\nlib_deps =\n  https://github.com/Terrapin-Rocket-Team/Astra.git\nbuild_flags =\n  -D ENV_TEENSY\n</code></pre> platformio.ini<pre><code>[env:stm32h723vehx]\nplatform = ststm32\nboard = stm32h723vehx\nframework = arduino\nlib_deps =\n  https://github.com/Terrapin-Rocket-Team/Astra.git\n  stm32duino/STM32duino STM32SD\n  https://github.com/stm32duino/FatFs.git\nbuild_flags =\n  -D ENV_STM\n</code></pre> platformio.ini<pre><code>[env:esp32]\nplatform = espressif32\nboard = esp32-s3-devkitm-1\nframework = arduino\nlib_deps =\n  https://github.com/Terrapin-Rocket-Team/Astra.git\nbuild_flags =\n  -D ENV_ESP\n</code></pre> <p>Tip</p> <p>Pin a specific release by appending a tag, e.g. <code>https://github.com/Terrapin-Rocket-Team/Astra.git#v0.2.0</code>.</p>"},{"location":"user-guide/installation/#native-build-sitl","title":"Native Build (SITL)","text":"<p>To run on your desktop for SITL testing, create a native environment:</p> platformio.ini<pre><code>[env:native]\nplatform = native\nlib_compat_mode = off\nlib_deps =\n  https://github.com/DrewBrandt/NativeTestMocks.git\nbuild_flags =\n  -D NATIVE=1\n  -D ARDUINO=100\n  -std=c++17\n</code></pre> <p>See SITL for details.</p>"},{"location":"user-guide/installation/#verify-the-build","title":"Verify the Build","text":"<p>Add a basic <code>main.cpp</code>:</p> src/main.cpp<pre><code>#include &lt;Arduino.h&gt;\n#include &lt;Utils/Astra.h&gt;\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\nvoid loop() {\n}\n</code></pre> <p>Build using PlatformIO. If the build succeeds, Astra is installed correctly.</p>"},{"location":"user-guide/intro/","title":"The Astra User Manual","text":"<p>This guide is written in the order shown in the sidebar. Each page stands alone, but later sections assume the basics.</p> <p>If you\u2019re unsure where to start, read Installation and Basic Usage first.</p>"},{"location":"user-guide/intro/#how-astra-is-organized","title":"How Astra Is Organized","text":"<p>Astra is built around three layers:</p> <ol> <li>System: <code>Astra</code> + <code>AstraConfig</code> coordinate everything</li> <li>Interfaces: <code>State</code>, <code>Sensor</code>, <code>DataReporter</code>, and filters define behavior</li> <li>Utilities: Logging, BlinkBuzz, math types, and helpers</li> </ol>"},{"location":"user-guide/intro/#high-level-data-flow","title":"High-Level Data Flow","text":"<pre><code>Sensors \u2192 Astra \u2192 State \u2192 DataLogger\n               \u2198 EventLogger (LOG/)\n</code></pre> <ul> <li>Sensors update at their own rates</li> <li><code>Astra</code> tracks updates and sensor health internally</li> <li><code>State</code> consumes vectors (gyro/accel/GPS/baro) and estimates pose</li> <li><code>DataLogger</code> writes CSV telemetry from all <code>DataReporter</code>s</li> </ul>"},{"location":"user-guide/intro/#key-concepts","title":"Key Concepts","text":"<p>DataReporter - Any class that registers columns for telemetry logging - Sensors and State inherit from it automatically</p> <p>Sensor Health - Base sensor classes track communication failures and stuck readings - <code>Astra</code> checks health before using data</p> <p>Orientation + Position - Orientation is estimated with Mahony AHRS - Position/velocity are estimated with a linear Kalman filter</p>"},{"location":"user-guide/intro/#recommended-starting-point","title":"Recommended Starting Point","text":"<p>If you want a working system quickly:</p> <ol> <li>Use <code>DefaultState</code> (built-in filters)</li> <li>Use <code>AstraConfig</code> with <code>with6DoFIMU()</code>, <code>withBaro()</code>, and <code>withGPS()</code></li> <li>Add log sinks and call <code>Astra::init()</code>/<code>Astra::update()</code></li> </ol> <p>See Basic Usage for a complete example.</p>"},{"location":"user-guide/sitl/","title":"SITL (Software\u2011In\u2011The\u2011Loop)","text":"<p>SITL runs Astra natively on your PC and connects to a simulator over TCP.</p>"},{"location":"user-guide/sitl/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Start the simulator:    <pre><code>python sitl_simulator.py --sim parabolic\n</code></pre></p> </li> <li> <p>Build for native:    <pre><code>pio run -e native\n</code></pre></p> </li> <li> <p>Run the program:    <pre><code>.pio/build/native/program.exe\n</code></pre></p> </li> </ol>"},{"location":"user-guide/sitl/#notes","title":"Notes","text":"<ul> <li>SITL uses the HITL message format over TCP</li> <li>The included example is in <code>examples/SITL_Example</code></li> <li>Use <code>Serial.connectSITL(host, port)</code> to connect</li> </ul>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting","text":""},{"location":"user-guide/troubleshooting/#no-state-provided-warning","title":"\u201cNo State provided\u201d warning","text":"<p>If you do not call <code>withState()</code>, Astra will create a <code>DefaultState</code> automatically. If you want a custom filter stack, pass your own <code>State</code>.</p>"},{"location":"user-guide/troubleshooting/#telemetry-header-missing-or-incomplete","title":"Telemetry header missing or incomplete","text":"<p>Make sure all <code>DataReporter</code> objects are constructed before <code>Astra::init()</code> so the header includes their columns.</p>"},{"location":"user-guide/troubleshooting/#no-logs-coming-out","title":"No logs coming out","text":"<ul> <li>Ensure you configured sinks:</li> <li><code>withEventLogs()</code> or <code>EventLogger::configure()</code> for event logs</li> <li><code>withDataLogs()</code> for telemetry</li> <li>Check that your sink returns <code>ok() == true</code></li> </ul>"},{"location":"user-guide/troubleshooting/#gps-shows-no-fix","title":"GPS shows no fix","text":"<p><code>GPS::getHasFix()</code> only returns true when fix quality \u2265 4. You may need a clear sky view and time to lock.</p>"},{"location":"user-guide/troubleshooting/#coordinate-frame-confusion","title":"Coordinate frame confusion","text":"<p><code>State</code> uses ENU (East, North, Up). Some older docs mention NEU or NED; those are outdated.</p>"},{"location":"user-guide/ifaces/data-reporter/","title":"DataReporter","text":"<p><code>DataReporter</code> is the telemetry interface. Any class that inherits from it can register CSV columns and be logged by <code>DataLogger</code>.</p> <p>Sensors and <code>State</code> already inherit from <code>DataReporter</code>.</p>"},{"location":"user-guide/ifaces/data-reporter/#how-it-works","title":"How It Works","text":"<ol> <li>Create a <code>DataReporter</code></li> <li>Register columns in the constructor</li> <li>Implement <code>begin()</code> and <code>update()</code></li> <li>The reporter auto-registers with <code>DataLogger</code></li> </ol> <p><code>DataLogger</code> will call <code>update()</code> automatically if <code>autoUpdate</code> is true.</p>"},{"location":"user-guide/ifaces/data-reporter/#minimal-example","title":"Minimal Example","text":"<pre><code>#include &lt;RecordData/DataReporter/DataReporter.h&gt;\n\nusing namespace astra;\n\nclass BatteryMonitor : public DataReporter {\npublic:\n    BatteryMonitor() : DataReporter(\"Battery\") {\n        addColumn(\"%.2f\", &amp;voltage, \"voltage_v\");\n        addColumn(\"%.1f\", &amp;tempC, \"temp_c\");\n    }\n\n    int begin() override { return 0; }\n\n    int update(double currentTime = -1) override {\n        voltage = readVoltage();\n        tempC = readTemp();\n        return 0;\n    }\n\nprivate:\n    float voltage = 0.0f;\n    float tempC = 0.0f;\n\n    float readVoltage() { return 12.4f; }\n    float readTemp() { return 25.0f; }\n};\n</code></pre> <p>Construct this before <code>Astra::init()</code> so the header includes its columns.</p>"},{"location":"user-guide/ifaces/data-reporter/#column-registration","title":"Column Registration","text":"<pre><code>addColumn(\"%.3f\", &amp;value, \"label\");\ninsertColumn(0, \"%.1f\", &amp;other, \"first\");\nremoveColumn(\"label\");\n</code></pre> <p>Formats use <code>printf</code> rules.</p>"},{"location":"user-guide/ifaces/data-reporter/#auto-update-control","title":"Auto Update Control","text":"<pre><code>reporter.setAutoUpdate(false);\n</code></pre> <p>If <code>autoUpdate</code> is false, you must call <code>update()</code> yourself before telemetry logging.</p> <p>Sensors and <code>State</code> set <code>autoUpdate = false</code> because Astra updates them separately.</p>"},{"location":"user-guide/ifaces/filters/","title":"Filters","text":"<p>Astra uses two filter layers:</p> <ul> <li>Orientation: <code>MahonyAHRS</code></li> <li>Position/Velocity: <code>LinearKalmanFilter</code> (usually <code>DefaultKalmanFilter</code>)</li> </ul> <p><code>State</code> consumes both.</p>"},{"location":"user-guide/ifaces/filters/#linearkalmanfilter","title":"LinearKalmanFilter","text":"<p><code>LinearKalmanFilter</code> is an abstract base class. You override the matrix methods:</p> <pre><code>class LinearKalmanFilter {\npublic:\n    virtual void initialize() = 0;\n    virtual Matrix getF(double dt) = 0;\n    virtual Matrix getG(double dt) = 0;\n    virtual Matrix getH() = 0;\n    virtual Matrix getR() = 0;\n    virtual Matrix getQ(double dt) = 0;\n\n    void predict(double dt, Matrix control);\n    void update(Matrix measurement);\n    void update(Matrix z, Matrix H, Matrix R);\n    void updateGPS(double px, double py, double gpsNoise = -1.0);\n    void updateBaro(double pz, double baroNoise = -1.0);\n    void updateGPSBaro(double px, double py, double pz,\n                       double gpsNoise = -1.0, double baroNoise = -1.0);\n};\n</code></pre>"},{"location":"user-guide/ifaces/filters/#defaultkalmanfilter","title":"DefaultKalmanFilter","text":"<p><code>DefaultKalmanFilter</code> is a 6\u2011state position/velocity filter:</p> <pre><code>[px, py, pz, vx, vy, vz]\n</code></pre> <p>It expects:</p> <ul> <li>Control: acceleration (ENU)</li> <li>Measurements: GPS horizontal position + baro altitude</li> </ul> <pre><code>DefaultKalmanFilter kf(1.0, 5.0, 2.0);\nMahonyAHRS ahrs;\nState state(&amp;kf, &amp;ahrs);\n</code></pre>"},{"location":"user-guide/ifaces/filters/#mahonyahrs","title":"MahonyAHRS","text":"<p><code>MahonyAHRS</code> estimates orientation from accel + gyro (and optional mag). It outputs a quaternion and earth-frame acceleration.</p> <pre><code>MahonyAHRS ahrs(0.1, 0.0005);\n</code></pre> <p>If magnetometer calibration is performed, yaw stabilization improves.</p>"},{"location":"user-guide/ifaces/filters/#recommended-path","title":"Recommended Path","text":"<p>Most projects should start with:</p> <pre><code>DefaultState state;\n</code></pre> <p>This wires <code>DefaultKalmanFilter</code> + <code>MahonyAHRS</code> automatically.</p>"},{"location":"user-guide/ifaces/sensor/","title":"Sensor Interface","text":"<p><code>Sensor</code> is the base class for all hardware sensors in Astra. It inherits from <code>DataReporter</code>, so every sensor can publish telemetry automatically.</p>"},{"location":"user-guide/ifaces/sensor/#core-concepts","title":"Core Concepts","text":"<ul> <li><code>begin()</code> initializes hardware</li> <li><code>update()</code> reads fresh data</li> <li><code>setUpdateRate(hz)</code> controls how often the sensor should update</li> <li><code>isHealthy()</code> indicates whether the sensor\u2019s data can be trusted</li> </ul> <p>Sensors implement <code>init()</code> and <code>read()</code> internally. <code>begin()</code> and <code>update()</code> call these for you.</p>"},{"location":"user-guide/ifaces/sensor/#key-methods","title":"Key Methods","text":"<pre><code>int begin();\nint update(double currentTime = -1);\nvoid setUpdateRate(double hz);\nbool isHealthy() const;\nbool isInitialized() const;\n</code></pre>"},{"location":"user-guide/ifaces/sensor/#update-rate","title":"Update Rate","text":"<p>Sensors decide when to update based on <code>setUpdateRate()</code> and <code>shouldUpdate(currentTime)</code>. <code>Astra</code> calls <code>update()</code> only when the interval has elapsed.</p> <pre><code>imu.setUpdateRate(100);  // 100 Hz\nbaro.setUpdateRate(20);  // 20 Hz\ngps.setUpdateRate(5);    // 5 Hz\n</code></pre>"},{"location":"user-guide/ifaces/sensor/#health-tracking","title":"Health Tracking","text":"<p>Base sensor types (Accel/Gyro/Mag/Baro) detect:</p> <ul> <li>Read failures</li> <li>Stuck readings (values not changing)</li> </ul> <p><code>isHealthy()</code> will return <code>false</code> if the sensor is unreliable.</p>"},{"location":"user-guide/ifaces/sensor/#rotatable-sensors","title":"Rotatable Sensors","text":"<p><code>Accel</code>, <code>Gyro</code>, <code>Mag</code>, and <code>IMU</code> inherit from <code>RotatableSensor</code>, which allows you to set board mounting orientation:</p> <pre><code>imu.setMountingOrientation(MountingOrientation::ROTATE_90_Z);\n</code></pre>"},{"location":"user-guide/ifaces/sensor/#implementing-a-custom-sensor","title":"Implementing a Custom Sensor","text":"<pre><code>#include &lt;Sensors/Sensor.h&gt;\n\nclass MySensor : public astra::Sensor {\npublic:\n    MySensor() : Sensor(\"MySensor\") {\n        addColumn(\"%.2f\", &amp;value, \"value\");\n    }\n\n    int begin() override { return init(); }\n    int update(double currentTime = -1) override { return read(); }\n\nprotected:\n    int init() override {\n        // Hardware init\n        return 0;\n    }\n\n    int read() override {\n        value = 42.0f;\n        return 0;\n    }\n\nprivate:\n    float value = 0.0f;\n};\n</code></pre>"},{"location":"user-guide/ifaces/sensor/#available-builtin-sensors","title":"Available Built\u2011In Sensors","text":"<p>See the specific sensor pages:</p> <ul> <li>Accelerometer</li> <li>Gyroscope</li> <li>Magnetometer</li> <li>Barometer</li> <li>GPS</li> <li>Voltage Sensor</li> <li>HITL Sensors</li> </ul>"},{"location":"user-guide/ifaces/state/","title":"State","text":"<p><code>State</code> is Astra\u2019s math-only state estimator. It does not own sensors. Instead, it consumes vectors (gyro/accel/GPS/baro) and outputs position, velocity, acceleration, and orientation.</p> <p><code>Astra</code> drives the update flow automatically.</p>"},{"location":"user-guide/ifaces/state/#coordinate-system","title":"Coordinate System","text":"<p>Inertial frame: ENU</p> <ul> <li>X = East  </li> <li>Y = North  </li> <li>Z = Up  </li> </ul> <p>Orientation and position are expressed in this frame.</p>"},{"location":"user-guide/ifaces/state/#construction","title":"Construction","text":"<p>You can build your own filter stack:</p> <pre><code>#include &lt;Filters/DefaultKalmanFilter.h&gt;\n#include &lt;Filters/Mahony.h&gt;\n\nDefaultKalmanFilter kf;\nMahonyAHRS ahrs;\n\nState state(&amp;kf, &amp;ahrs);\n</code></pre> <p>Or use the default implementation:</p> <pre><code>DefaultState state;\n</code></pre>"},{"location":"user-guide/ifaces/state/#update-api-vectorbased","title":"Update API (Vector\u2011Based)","text":"<p>Use the vector API:</p> <pre><code>void updateOrientation(const Vector&lt;3&gt;&amp; gyro,\n                       const Vector&lt;3&gt;&amp; accel,\n                       double dt);\n\nvoid predict(double dt);\n\nvoid updateGPSMeasurement(const Vector&lt;3&gt;&amp; gpsPos,\n                          const Vector&lt;3&gt;&amp; gpsVel);\n\nvoid updateBaroMeasurement(double baroAlt);\n</code></pre> <p><code>Astra</code> calls these for you. You generally don\u2019t call them directly.</p>"},{"location":"user-guide/ifaces/state/#outputs","title":"Outputs","text":"<pre><code>Vector&lt;3&gt; getPosition() const;        // ENU position (m)\nVector&lt;3&gt; getVelocity() const;        // ENU velocity (m/s)\nVector&lt;3&gt; getAcceleration() const;    // ENU linear accel (m/s^2)\nQuaternion getOrientation() const;    // Body \u2192 ENU\nVector&lt;2&gt; getCoordinates() const;     // GPS lat/lon\ndouble getHeading() const;            // degrees\n</code></pre>"},{"location":"user-guide/ifaces/state/#defaultstate","title":"DefaultState","text":"<p><code>DefaultState</code> creates and owns:</p> <ul> <li><code>DefaultKalmanFilter</code></li> <li><code>MahonyAHRS</code></li> </ul> <p>It\u2019s the easiest way to get started:</p> <pre><code>DefaultState state;\n</code></pre>"},{"location":"user-guide/ifaces/state/#extending-state","title":"Extending State","text":"<p>You can subclass <code>State</code> to add custom logic (launch detection, staging, etc.).</p> <pre><code>class RocketState : public State {\npublic:\n    RocketState(LinearKalmanFilter* f, MahonyAHRS* a) : State(f, a) {}\n\n    void updateCustomLogic() {\n        if (getAcceleration().z() &gt; 20) {\n            LOGI(\"Launch detected\");\n        }\n    }\n};\n</code></pre>"},{"location":"user-guide/ifaces/sensors/accel/","title":"Accelerometer","text":"<p><code>Accel</code> is the base class for 3\u2011axis accelerometers.</p>"},{"location":"user-guide/ifaces/sensors/accel/#key-methods","title":"Key Methods","text":"<pre><code>Vector&lt;3&gt; getAccel() const; // m/s^2\nbool isHealthy() const;\n</code></pre> <p><code>Accel</code> tracks stuck readings and will mark itself unhealthy if values stop changing.</p>"},{"location":"user-guide/ifaces/sensors/accel/#implementations","title":"Implementations","text":"Class Notes <code>ADXL375</code> High\u2011g ADXL375 <code>H3LIS331DL</code> High\u2011g LIS331 <p>Example:</p> <pre><code>#include &lt;Sensors/HW/Accel/ADXL375.h&gt;\n\nADXL375 accel(\"HighG\", &amp;Wire, 0x1D);\n</code></pre>"},{"location":"user-guide/ifaces/sensors/accel/#dualrangeaccel","title":"DualRangeAccel","text":"<p><code>DualRangeAccel</code> combines a low\u2011g and high\u2011g sensor with a blended transition region.</p> <pre><code>DualRangeAccel combo(&amp;lowG, &amp;highG, 150.0, 120.0);\n</code></pre> <ul> <li><code>maxLowG</code> and <code>minHighG</code> define the blend window  </li> <li>Values are in the same units as <code>getAccel()</code> (m/s\u00b2)</li> <li>Each underlying sensor keeps its own mounting orientation</li> </ul>"},{"location":"user-guide/ifaces/sensors/baro/","title":"Barometer","text":"<p><code>Barometer</code> standardizes pressure sensors and computes altitude automatically.</p>"},{"location":"user-guide/ifaces/sensors/baro/#units","title":"Units","text":"<ul> <li>Pressure: hPa (mbar)</li> <li>Temperature: \u00b0C</li> <li>Altitude: meters ASL</li> </ul>"},{"location":"user-guide/ifaces/sensors/baro/#key-methods","title":"Key Methods","text":"<pre><code>double getPressure() const;    // hPa\ndouble getTemp() const;        // \u00b0C\ndouble getTempF() const;       // \u00b0F\ndouble getPressureAtm() const; // atm\ndouble getASLAltM() const;     // meters\ndouble getASLAltFt() const;    // feet\n</code></pre>"},{"location":"user-guide/ifaces/sensors/baro/#implementations","title":"Implementations","text":"Class Notes <code>DPS368</code> DPS310-compatible (Adafruit driver) <code>BMP390</code> Bosch BMP3XX <code>MS5611</code> TE MS5611 <p>Example:</p> <pre><code>#include &lt;Sensors/HW/Baro/DPS368.h&gt;\n\nDPS368 baro(\"Baro\", &amp;Wire, 0x77);\n</code></pre>"},{"location":"user-guide/ifaces/sensors/baro/#altitude-calculation","title":"Altitude Calculation","text":"<p>Altitude is computed internally with:</p> <pre><code>alt_m = 44307.69 * (1 - (pressure / 1013.25) ^ 0.190284)\n</code></pre> <p>Where pressure is in hPa.</p>"},{"location":"user-guide/ifaces/sensors/baro/#logging-columns","title":"Logging Columns","text":"<p>By default, barometers log:</p> <ul> <li><code>Pres (hPa)</code></li> <li><code>Temp (C)</code></li> <li><code>Alt ASL (m)</code></li> </ul>"},{"location":"user-guide/ifaces/sensors/gps/","title":"GPS","text":"<p><code>GPS</code> provides position, velocity, heading, and time-of-day data.</p>"},{"location":"user-guide/ifaces/sensors/gps/#key-methods","title":"Key Methods","text":"<pre><code>Vector&lt;3&gt; getPos() const;   // lat, lon, alt (degrees, degrees, meters)\nVector&lt;3&gt; getVel() const;   // NED velocity (m/s)\ndouble getHeading() const;  // degrees\nbool getHasFix() const;     // true when fix quality &gt;= 4\nint getFixQual() const;     // satellites\n\nVector&lt;3&gt; getDisplacement(Vector&lt;3&gt; origin) const;\n</code></pre> <p>Time accessors:</p> <pre><code>const char* getTimeOfDay() const; // \"HH:MM:SS\"\nint8_t getHour() const;\nint8_t getMinute() const;\nint8_t getSecond() const;\nuint8_t getDay() const;\nuint8_t getMonth() const;\nuint16_t getYear() const;\n</code></pre>"},{"location":"user-guide/ifaces/sensors/gps/#implementations","title":"Implementations","text":"Class Notes <code>MAX_M10S</code> u-blox M10S <code>SAM_M10Q</code> Alias of MAX_M10S <p>Example:</p> <pre><code>#include &lt;Sensors/HW/GPS/MAX_M10S.h&gt;\n\nMAX_M10S gps(\"GPS\", &amp;Wire, 0x42);\n</code></pre>"},{"location":"user-guide/ifaces/sensors/gps/#logging-columns","title":"Logging Columns","text":"<p>GPS logs:</p> <ul> <li><code>Lat (deg)</code></li> <li><code>Lon (deg)</code></li> <li><code>Alt (m)</code></li> <li><code>vN (m/s)</code></li> <li><code>vE (m/s)</code></li> <li><code>vD (m/s)</code></li> <li><code>Fix Quality</code></li> <li><code>Time of Day</code></li> </ul>"},{"location":"user-guide/ifaces/sensors/gyro/","title":"Gyroscope","text":"<p><code>Gyro</code> is the base class for angular velocity sensors.</p>"},{"location":"user-guide/ifaces/sensors/gyro/#key-methods","title":"Key Methods","text":"<pre><code>Vector&lt;3&gt; getAngVel() const; // rad/s\nbool isHealthy() const;\n</code></pre> <p>Health tracking detects stuck readings similarly to <code>Accel</code>.</p>"},{"location":"user-guide/ifaces/sensors/gyro/#implementations","title":"Implementations","text":"<p>Standalone gyro drivers are not currently included. Most applications use the gyro component from an IMU:</p> <pre><code>IMU6DoF* imu = ...;\nGyro* gyro = imu-&gt;getGyroSensor();\n</code></pre>"},{"location":"user-guide/ifaces/sensors/hitl/","title":"HITL Sensors","text":"<p>HITL sensors read simulated data from <code>HITLSensorBuffer</code> instead of hardware.</p> <p>They are drop\u2011in replacements for hardware sensors and integrate with Astra normally.</p>"},{"location":"user-guide/ifaces/sensors/hitl/#available-hitl-sensors","title":"Available HITL Sensors","text":"<ul> <li><code>HITLBarometer</code></li> <li><code>HITLAccel</code></li> <li><code>HITLGyro</code></li> <li><code>HITLMag</code></li> <li><code>HITLGPS</code></li> </ul>"},{"location":"user-guide/ifaces/sensors/hitl/#message-format","title":"Message Format","text":"<p>HITL data is provided via <code>HITL/</code> messages:</p> <pre><code>HITL/timestamp,ax,ay,az,gx,gy,gz,mx,my,mz,pressure,temp,lat,lon,alt,fix,fixqual,heading\n</code></pre> <p>Units:</p> <ul> <li>Accel: m/s\u00b2</li> <li>Gyro: rad/s</li> <li>Mag: \u00b5T</li> <li>Pressure: hPa</li> <li>Temp: \u00b0C</li> <li>GPS lat/lon: degrees</li> <li>GPS alt: meters</li> <li>Fix: 0/1</li> <li>FixQual: satellites</li> </ul>"},{"location":"user-guide/ifaces/sensors/hitl/#parser-router","title":"Parser + Router","text":"<p>Use <code>SerialMessageRouter</code> to handle incoming HITL lines:</p> <pre><code>router.withInterface(&amp;Serial)\n      .withListener(\"HITL/\", [](const char* msg, const char* prefix, Stream* src) {\n          double simTime;\n          if (HITLParser::parse(msg, simTime)) {\n              sys.update(simTime);\n          }\n      });\n</code></pre> <p>If you use the full Astra system, register the listener on <code>sys.getMessageRouter()</code> and skip calling <code>router.update()</code> yourself.</p>"},{"location":"user-guide/ifaces/sensors/hitl/#recommended-reading","title":"Recommended Reading","text":"<p>See the full HITL Guide.</p>"},{"location":"user-guide/ifaces/sensors/imu/","title":"IMU (6\u2011DoF and 9\u2011DoF)","text":"<p>Astra models IMUs as composite sensors:</p> <ul> <li><code>IMU6DoF</code> \u2192 accelerometer + gyroscope</li> <li><code>IMU9DoF</code> \u2192 accelerometer + gyroscope + magnetometer</li> </ul> <p>Each IMU exposes component sensors so Astra can use them for state estimation.</p>"},{"location":"user-guide/ifaces/sensors/imu/#component-access","title":"Component Access","text":"<pre><code>IMU6DoF* imu = ...;\nAccel* accel = imu-&gt;getAccelSensor();\nGyro* gyro = imu-&gt;getGyroSensor();\n</code></pre> <pre><code>IMU9DoF* imu = ...;\nAccel* accel = imu-&gt;getAccelSensor();\nGyro* gyro = imu-&gt;getGyroSensor();\nMag* mag = imu-&gt;getMagSensor();\n</code></pre>"},{"location":"user-guide/ifaces/sensors/imu/#using-with-astraconfig","title":"Using with AstraConfig","text":"<pre><code>AstraConfig config = AstraConfig()\n    .with6DoFIMU(&amp;imu)  // or with9DoFIMU(&amp;imu)\n    .withState(&amp;state);\n</code></pre> <p>This automatically extracts the component sensors for <code>Astra</code>, and logs the IMU as a misc sensor.</p>"},{"location":"user-guide/ifaces/sensors/imu/#implementations","title":"Implementations","text":"Class Type <code>BMI088</code> 6\u2011DoF <code>BNO055</code> 9\u2011DoF <p>Example:</p> <pre><code>#include &lt;Sensors/HW/IMU/BMI088.h&gt;\n\nBMI088 imu(\"BMI088\", &amp;Wire);\n</code></pre>"},{"location":"user-guide/ifaces/sensors/imu/#mounting-orientation","title":"Mounting Orientation","text":"<p>IMUs are <code>RotatableSensor</code>s. If the sensor is rotated on the board:</p> <pre><code>imu.setMountingOrientation(MountingOrientation::ROTATE_90_Z);\n</code></pre> <p>This orientation is propagated to the component sensors.</p>"},{"location":"user-guide/ifaces/sensors/imu/#orientation-note","title":"Orientation Note","text":"<p>IMU classes only report raw sensor data. Orientation is estimated in <code>State</code> via <code>MahonyAHRS</code>.</p>"},{"location":"user-guide/ifaces/sensors/mag/","title":"Magnetometer","text":"<p><code>Mag</code> is the base class for magnetometers.</p>"},{"location":"user-guide/ifaces/sensors/mag/#key-methods","title":"Key Methods","text":"<pre><code>Vector&lt;3&gt; getMag() const; // microtesla (uT)\n</code></pre>"},{"location":"user-guide/ifaces/sensors/mag/#implementations","title":"Implementations","text":"Class Notes <code>MMC5603NJ</code> Adafruit MMC5603 <p>Example:</p> <pre><code>#include &lt;Sensors/HW/Mag/MMC5603NJ.h&gt;\n\nMMC5603NJ mag(\"Mag\", &amp;Wire);\n</code></pre>"},{"location":"user-guide/ifaces/sensors/mag/#with-an-imu","title":"With an IMU","text":"<p>If your IMU provides magnetometer data:</p> <pre><code>IMU9DoF* imu = ...;\nMag* mag = imu-&gt;getMagSensor();\n</code></pre>"},{"location":"user-guide/ifaces/sensors/voltage/","title":"VoltageSensor","text":"<p><code>VoltageSensor</code> reads a voltage via ADC and (optionally) a resistor divider.</p>"},{"location":"user-guide/ifaces/sensors/voltage/#constructors","title":"Constructors","text":"<pre><code>VoltageSensor(int pin, const char* name = \"Voltage Sensor\");\nVoltageSensor(int pin, int r1, int r2,\n              const char* name = \"Voltage Sensor\",\n              double refVoltage = PLATFORM_DEFAULT_REF_VOLTAGE);\n</code></pre> <ul> <li><code>r1</code> and <code>r2</code> are divider resistances (ohms)</li> <li><code>refVoltage</code> is the ADC reference voltage</li> </ul>"},{"location":"user-guide/ifaces/sensors/voltage/#usage","title":"Usage","text":"<pre><code>VoltageSensor vbat(A0, 10000, 2000, \"Battery\");\n\ndouble v = vbat.getVoltage();\nint raw = vbat.getRawValue();\n</code></pre>"},{"location":"user-guide/ifaces/sensors/voltage/#notes","title":"Notes","text":"<ul> <li>ADC resolution is platform-specific</li> <li>The default reference voltage is chosen by build flags (<code>ENV_TEENSY</code>, <code>ENV_STM</code>, <code>ENV_ESP</code>)</li> </ul>"},{"location":"user-guide/utils/blinkbuzz/","title":"BlinkBuzz","text":"<p>The <code>BlinkBuzz</code> utility provides asynchronous LED and buzzer pattern control without blocking your main loop. It handles simple patterns like beeping a fixed number of times, complex patterns like SOS in Morse code, and repeating patterns that run indefinitely. The utility is designed to be used as-is without modification or subclassing.</p>"},{"location":"user-guide/utils/blinkbuzz/#overview","title":"Overview","text":"<p>BlinkBuzz operates in two modes:</p> <ol> <li>Synchronous - Blocking calls that hold execution until the pattern completes</li> <li>Asynchronous - Non-blocking patterns that execute in the background while your code continues</li> </ol> <p>The asynchronous mode is the primary use case, allowing status indication (stage changes, GPS lock, errors) without interrupting critical sensor updates or state estimation.</p>"},{"location":"user-guide/utils/blinkbuzz/#setup","title":"Setup","text":"<p>BlinkBuzz can be used standalone or with <code>AstraConfig</code>. The only difference is initialization\u2014all other functions work identically.</p>"},{"location":"user-guide/utils/blinkbuzz/#with-astraconfig-recommended","title":"With AstraConfig (Recommended)","text":"<pre><code>#include &lt;Astra.h&gt;\n\nint GPS_STATUS_PIN = 25;\n\nAstraConfig config = AstraConfig()\n                    .withBuzzerPin(13)              // Buzzer on pin 13\n                    .withBBPin(LED_BUILTIN)         // LED on built-in pin\n                    .withBBPin(GPS_STATUS_PIN)      // Add as many pins as needed\n                    .withBBAsync(true, 50);         // Enable async, queue size 50\n\nAstra system(&amp;config);\n\nvoid setup() {\n    system.init();  // Initializes BlinkBuzz automatically\n}\n\nvoid loop() {\n    system.update();  // Updates async patterns automatically\n}\n</code></pre> <p>Configuration options:</p> Method Description Notes <code>withBuzzerPin(int)</code> Set buzzer pin Also registers the pin <code>withBBPin(int)</code> Add LED/buzzer pin Call multiple times for multiple pins <code>withBBAsync(bool, int)</code> Enable async mode with queue size Set explicitly for clarity"},{"location":"user-guide/utils/blinkbuzz/#without-astraconfig","title":"Without AstraConfig","text":"<p>If you prefer standalone usage, initialize manually:</p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nint allowedPins[] = {LED_BUILTIN, 33};\n// Note: `bb` is already defined by the library; you do not need to define it.\n\ndouble lastTime = 0;\n\nvoid setup() {\n    bb.init(allowedPins, 2, true, 50);\n    // Args: pin array, pin count, enable async, queue size per pin\n}\n\nvoid loop() {\n    bb.update();  // Call frequently for accurate timing\n\n    // Avoid delay() when using async patterns\n    double time = millis();\n    if (time - lastTime &lt; 100)  // 100ms loop interval\n        return;\n    lastTime = time;\n\n    // Rest of your loop code\n}\n</code></pre> <p>Memory Overhead</p> <p>Async patterns use queues to store ON/OFF toggle events. Each pattern adds to the queue (e.g., 3 beeps = 6 toggles: ON, OFF, ON, OFF, ON, OFF). Keep queue sizes reasonable to avoid excessive memory usage.</p>"},{"location":"user-guide/utils/blinkbuzz/#synchronous-usage","title":"Synchronous Usage","text":"<p>Synchronous calls block execution until the pattern completes. Use these in <code>setup()</code> for initialization feedback, or when async mode is disabled.</p> <pre><code>#include &lt;BlinkBuzz.h&gt;\n\nvoid setup() {\n    // Hold pin on/off\n    bb.on(BUZZER);   // Turn on\n    bb.off(BUZZER);  // Turn off\n\n    // Simple patterns\n    bb.onoff(BUZZER, 200);          // Single 200ms beep\n    bb.onoff(BUZZER, 200, 5);       // 5 beeps: 200ms on, 200ms off\n    bb.onoff(BUZZER, 200, 3, 100);  // 3 beeps: 200ms on, 100ms off\n}\n</code></pre> <p>Parameters:</p> Function Parameters Description <code>on(pin)</code> <code>pin</code> Turn pin on indefinitely <code>off(pin)</code> <code>pin</code> Turn pin off <code>onoff(pin, dur)</code> <code>pin</code>, <code>dur</code> Single pulse of <code>dur</code> ms <code>onoff(pin, dur, reps)</code> <code>pin</code>, <code>dur</code>, <code>reps</code> Repeat <code>reps</code> times, equal on/off <code>onoff(pin, dur, reps, off)</code> <code>pin</code>, <code>dur</code>, <code>reps</code>, <code>off</code> Repeat <code>reps</code> times, <code>off</code> ms between <p>Synchronous Limitations</p> <p><code>BBPattern</code> objects are not supported in synchronous mode. Use async mode for complex patterns.</p>"},{"location":"user-guide/utils/blinkbuzz/#asynchronous-usage","title":"Asynchronous Usage","text":"<p>Async mode is where BlinkBuzz shines. Patterns execute in the background without blocking, making them perfect for status indication during flight.</p>"},{"location":"user-guide/utils/blinkbuzz/#basic-async-patterns","title":"Basic Async Patterns","text":"<pre><code>// Single beep\nbb.aonoff(BUZZER, 200);\n\n// 5 beeps, 200ms on/off\nbb.aonoff(BUZZER, 200, 5);\n\n// 3 beeps, 200ms on, 100ms off\nbb.aonoff(BUZZER, 200, 3, 100);\n\n// Clear pending patterns on a pin\nbb.clearQueue(BUZZER);\n</code></pre> <p>Parameters match synchronous <code>onoff()</code>, but with <code>a</code> prefix for async.</p>"},{"location":"user-guide/utils/blinkbuzz/#complex-patterns-with-bbpattern","title":"Complex Patterns with BBPattern","text":"<p>The <code>BBPattern</code> class builds complex patterns by combining simpler ones. You can chain patterns together and add \"rests\" (pauses) between repetitions.</p> <p>Basic BBPattern usage:</p> <pre><code>BBPattern pattern = BBPattern(ON_DURATION, REPEATS, OFF_DURATION);\n\n// Example: SOS in Morse code\nBBPattern s(50, 3, 200);   // S: 3 short beeps\nBBPattern o(500, 3, 200);  // O: 3 long beeps\n\n// Combine patterns using a() (append)\nBBPattern sos;\nsos.a(s).a(o).a(s);\n\n// Execute the pattern\nbb.aonoff(BUZZER, sos);\n</code></pre> <p>Repeating patterns indefinitely:</p> <pre><code>// Repeat SOS pattern forever\nbb.aonoff(BUZZER, sos, true);\n\n// Add 1 second rest between repetitions\nbb.aonoff(BUZZER, sos.r(1000), true);\n</code></pre> <p>Pattern Construction</p> <p>Do not use <code>BBPattern sos = s.a(o).a(s);</code> \u2014 this won't work as expected due to how chaining is implemented. Instead, create an empty pattern and append to it: <pre><code>BBPattern sos;\nsos.a(s).a(o).a(s);  // Correct\n</code></pre></p> <p>BBPattern methods:</p> Method Description <code>BBPattern(dur, reps, off)</code> Create pattern: <code>dur</code> ms on, <code>reps</code> times, <code>off</code> ms between <code>a(pattern)</code> Append another pattern <code>r(duration)</code> Add rest (pause) at the end"},{"location":"user-guide/utils/blinkbuzz/#practical-examples","title":"Practical Examples","text":""},{"location":"user-guide/utils/blinkbuzz/#gps-lock-indicator","title":"GPS Lock Indicator","text":"<pre><code>int GPS_PIN = 25;\n\nvoid loop() {\n    system.update();\n\n    if (gps.getHasFix()) {\n        // Solid on when locked\n        bb.on(GPS_PIN);\n    } else {\n        // Slow blink when searching\n        bb.aonoff(GPS_PIN, 500, 1);  // 500ms on, 500ms off, repeats\n    }\n}\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#stage-change-notifications","title":"Stage Change Notifications","text":"<pre><code>class CustomState : public State {\n    void update(double currentTime) override {\n        State::update(currentTime);\n\n        int newStage = determineStage();\n        if (newStage != stage) {\n            stage = newStage;\n\n            // Beep N times for stage N\n            bb.aonoff(BUZZER, 200, stage);\n\n            LOGI(\"Entered stage %d\", stage);\n        }\n    }\n};\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#armed-status-pattern","title":"Armed Status Pattern","text":"<pre><code>void setup() {\n    system.init();\n\n    // Armed: rapid beep pattern\n    BBPattern armed(100, 3, 50);  // 3 quick beeps\n    bb.aonoff(BUZZER, armed.r(2000), true);  // Repeat every 2s\n\n    LOGI(\"System armed\");\n}\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#complex-morse-code-patterns","title":"Complex Morse Code Patterns","text":"<pre><code>// Morse: -- --- -.- (M O K)\nBBPattern dash(300, 1, 100);\nBBPattern dot(100, 1, 100);\nBBPattern letterGap(0, 1, 300);\n\nBBPattern m;\nm.a(dash).a(dash).a(letterGap);\n\nBBPattern o;\no.a(dash).a(dash).a(dash).a(letterGap);\n\nBBPattern k;\nk.a(dash).a(dot).a(dash).a(letterGap);\n\nBBPattern mok;\nmok.a(m).a(o).a(k);\n\nbb.aonoff(BUZZER, mok, true);  // Repeat \"MOK\" indefinitely\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#queue-management","title":"Queue Management","text":"<p>Each pin has its own queue of pending toggles (ON/OFF transitions). Queue size is set during initialization.</p> <p>Queue considerations:</p> <ul> <li>Each <code>aonoff(pin, dur, reps)</code> adds <code>2 * reps</code> events to the queue (ON + OFF per repetition)</li> <li>Repeating patterns (<code>aonoff(pin, pattern, true)</code>) continuously refill the queue</li> <li>Use <code>clearQueue(pin)</code> to cancel all pending patterns on a pin</li> <li>If the queue fills, new patterns are rejected (logged as warning)</li> </ul> <p>Example:</p> <pre><code>bb.aonoff(BUZZER, 200, 3);  // Adds 6 events: ON, OFF, ON, OFF, ON, OFF\n\n// Cancel before completion\nbb.clearQueue(BUZZER);  // Remaining events discarded\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Call <code>update()</code> frequently: The more often <code>update()</code> is called, the more accurate pattern timing will be. Avoid long delays in your loop.</p> </li> <li> <p>Avoid <code>delay()</code> with async mode: Use time-based loop control instead:    <pre><code>double lastTime = 0;\nvoid loop() {\n    bb.update();\n\n    double time = millis();\n    if (time - lastTime &lt; 100) return;\n    lastTime = time;\n\n    // Your loop code\n}\n</code></pre></p> </li> <li> <p>Size queues appropriately: Use the minimum queue size needed for your patterns. Typical values: 20-50 per pin.</p> </li> <li> <p>Clear queues on stage transitions: Prevent old patterns from interfering with new ones:    <pre><code>if (stageChanged) {\n    bb.clearQueue(BUZZER);\n    bb.aonoff(BUZZER, 200, newStage);  // Beep for new stage\n}\n</code></pre></p> </li> <li> <p>Test patterns in <code>setup()</code>: Use synchronous patterns during initialization to verify hardware:    <pre><code>void setup() {\n    system.init();\n    bb.onoff(BUZZER, 100, 2);  // Sync beeps confirm buzzer works\n}\n</code></pre></p> </li> <li> <p>Use multiple pins for different statuses: Dedicate pins to specific indicators (GPS, stage, errors) for clear status at a glance.</p> </li> </ol>"},{"location":"user-guide/utils/blinkbuzz/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/utils/blinkbuzz/#heartbeat","title":"Heartbeat","text":"<pre><code>// Continuous heartbeat: quick double beep, long pause\nBBPattern heartbeat(50, 2, 100);\nbb.aonoff(LED_BUILTIN, heartbeat.r(2000), true);\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#error-alarm","title":"Error Alarm","text":"<pre><code>// Rapid continuous beeping\nbb.aonoff(BUZZER, 100, -1);  // Infinite repetitions (use clearQueue to stop)\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#count-up-sequence","title":"Count-Up Sequence","text":"<pre><code>// Beep 1, 2, 3, 4 times with pauses\nfor (int i = 1; i &lt;= 4; i++) {\n    BBPattern count(200, i, 150);\n    bb.aonoff(BUZZER, count.r(1000));\n}\n</code></pre>"},{"location":"user-guide/utils/blinkbuzz/#limitations","title":"Limitations","text":"<ul> <li>No pattern modification: Once a pattern enters the queue, it cannot be changed. Use <code>clearQueue()</code> and resubmit.</li> <li>Fixed queue sizes: Queue size is set at initialization and cannot grow dynamically.</li> <li>Synchronous patterns don't support BBPattern: Only async mode supports <code>BBPattern</code> objects.</li> <li>No priority system: Patterns execute in submission order. Use <code>clearQueue()</code> for urgent patterns.</li> </ul>"},{"location":"user-guide/utils/blinkbuzz/#summary","title":"Summary","text":"<ul> <li><code>BlinkBuzz</code> provides non-blocking LED and buzzer control</li> <li>Use <code>aonoff()</code> for simple async patterns</li> <li>Use <code>BBPattern</code> to build complex patterns from simpler components</li> <li>Call <code>update()</code> frequently for accurate timing</li> <li>Use <code>clearQueue()</code> to cancel pending patterns</li> <li>Integrate with <code>AstraConfig</code> for automatic initialization and updates</li> </ul> <p>For integration with the main system, see the Basic Use guide.</p>"},{"location":"user-guide/utils/circbuffer/","title":"CircBuffer","text":"<p>The <code>CircBuffer</code> (circular buffer) is a templated queue implementation that provides fixed-size FIFO (First In, First Out) storage with random access. It's designed for storing recent sensor readings, implementing moving averages, and buffering time-series data without dynamic memory allocation after initialization.</p>"},{"location":"user-guide/utils/circbuffer/#overview","title":"Overview","text":"<p>A circular buffer maintains a fixed-size array that wraps around when full. New elements overwrite the oldest data automatically. This makes it ideal for:</p> <ol> <li>Moving averages - Store recent sensor readings to calculate averages</li> <li>Ground calibration - Buffer sensor data during pre-launch to establish baselines</li> <li>Signal filtering - Smooth noisy sensor data</li> <li>Time-series analysis - Keep a sliding window of recent measurements</li> </ol> <p>The <code>CircBuffer</code> supports both queue operations (push/pop) and array-like random access via the <code>[]</code> operator.</p>"},{"location":"user-guide/utils/circbuffer/#template-definition","title":"Template Definition","text":"<pre><code>template &lt;typename T&gt;\nclass CircBuffer {\npublic:\n    CircBuffer(int size);\n\n    void push(T item);\n    T pop();\n    T peek();\n\n    int getCount();\n    int getSize();\n    bool isFull();\n    bool isEmpty();\n    void clear();\n\n    T&amp; operator[](int index);\n    T operator[](int index) const;\n};\n</code></pre> <p>Type parameter <code>T</code>: Can be any type (<code>double</code>, <code>int</code>, <code>Vector&lt;3&gt;</code>, custom structs, etc.)</p>"},{"location":"user-guide/utils/circbuffer/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/utils/circbuffer/#creating-a-buffer","title":"Creating a Buffer","text":"<pre><code>#include &lt;CircBuffer.h&gt;\n\n// Buffer for 100 double values\nCircBuffer&lt;double&gt; pressureBuffer(100);\n\n// Buffer for 50 3D vectors\nCircBuffer&lt;Vector&lt;3&gt;&gt; positionBuffer(50);\n\n// Buffer for custom types\nstruct SensorReading {\n    double timestamp;\n    double value;\n};\nCircBuffer&lt;SensorReading&gt; dataBuffer(200);\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#adding-and-removing-elements","title":"Adding and Removing Elements","text":"<pre><code>CircBuffer&lt;double&gt; buffer(5);\n\n// Add elements\nbuffer.push(1.5);\nbuffer.push(2.3);\nbuffer.push(3.7);\n\n// Remove oldest element\ndouble oldest = buffer.pop();  // Returns 1.5\n\n// View oldest without removing\ndouble next = buffer.peek();   // Returns 2.3 (doesn't remove)\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#random-access","title":"Random Access","text":"<pre><code>CircBuffer&lt;double&gt; buffer(10);\nbuffer.push(10.0);\nbuffer.push(20.0);\nbuffer.push(30.0);\n\n// Access by index (0 = oldest element)\ndouble oldest = buffer[0];     // 10.0\ndouble newest = buffer[buffer.getCount() - 1];  // 30.0\n\n// Iterate over all elements\nfor (int i = 0; i &lt; buffer.getCount(); i++) {\n    Serial.println(buffer[i]);\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#core-methods","title":"Core Methods","text":""},{"location":"user-guide/utils/circbuffer/#pushitem","title":"push(item)","text":"<p>Add an item to the buffer. If full, overwrites the oldest element.</p> <pre><code>CircBuffer&lt;double&gt; buffer(3);\nbuffer.push(1.0);\nbuffer.push(2.0);\nbuffer.push(3.0);\nbuffer.push(4.0);  // Overwrites 1.0\n\n// Buffer now contains: [2.0, 3.0, 4.0]\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#pop","title":"pop()","text":"<p>Remove and return the oldest element. Returns default-constructed value if empty.</p> <pre><code>CircBuffer&lt;int&gt; buffer(5);\nbuffer.push(10);\nbuffer.push(20);\n\nint val = buffer.pop();  // Returns 10\n// Buffer now contains: [20]\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#peek","title":"peek()","text":"<p>View the oldest element without removing it. Returns default-constructed value if empty.</p> <pre><code>CircBuffer&lt;double&gt; buffer(5);\nbuffer.push(1.5);\n\ndouble val = buffer.peek();  // Returns 1.5\n// Buffer still contains: [1.5]\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#getcount","title":"getCount()","text":"<p>Returns the number of elements currently in the buffer.</p> <pre><code>CircBuffer&lt;int&gt; buffer(10);\nbuffer.push(1);\nbuffer.push(2);\n\nint count = buffer.getCount();  // Returns 2\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#getsize","title":"getSize()","text":"<p>Returns the maximum capacity of the buffer.</p> <pre><code>CircBuffer&lt;int&gt; buffer(100);\nint capacity = buffer.getSize();  // Returns 100\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#isfull","title":"isFull()","text":"<p>Returns <code>true</code> if the buffer is at maximum capacity.</p> <pre><code>CircBuffer&lt;int&gt; buffer(3);\nbuffer.push(1);\nbuffer.push(2);\nbuffer.push(3);\n\nif (buffer.isFull()) {\n    // Buffer is full, next push will overwrite oldest\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#isempty","title":"isEmpty()","text":"<p>Returns <code>true</code> if the buffer contains no elements.</p> <pre><code>CircBuffer&lt;int&gt; buffer(10);\n\nif (buffer.isEmpty()) {\n    // No elements to pop\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#clear","title":"clear()","text":"<p>Remove all elements from the buffer without changing capacity.</p> <pre><code>CircBuffer&lt;int&gt; buffer(10);\nbuffer.push(1);\nbuffer.push(2);\nbuffer.clear();\n\n// Buffer is now empty, count = 0\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#practical-examples","title":"Practical Examples","text":""},{"location":"user-guide/utils/circbuffer/#moving-average-filter","title":"Moving Average Filter","text":"<p>Calculate the average of the last N sensor readings:</p> <pre><code>CircBuffer&lt;double&gt; pressureBuffer(100);\n\nvoid loop() {\n    double pressure = baro.getPressure();\n    pressureBuffer.push(pressure);\n\n    // Calculate average\n    double sum = 0;\n    int count = pressureBuffer.getCount();\n    for (int i = 0; i &lt; count; i++) {\n        sum += pressureBuffer[i];\n    }\n    double avgPressure = sum / count;\n\n    LOGI(\"Pressure: %.2f Pa (avg: %.2f)\", pressure, avgPressure);\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#ground-level-calibration","title":"Ground Level Calibration","text":"<p>Buffer sensor data before launch to establish a ground reference:</p> <pre><code>class CustomBarometer : public Barometer {\nprivate:\n    CircBuffer&lt;double&gt; pressureBuffer{100};  // Buffer for calibration\n    bool calibrated = false;\n    double groundPressure = 0;\n\nprotected:\n    bool read() override {\n        pressure = hardware.readPressure();\n\n        if (!calibrated) {\n            pressureBuffer.push(pressure);\n\n            // Use first 50 readings for calibration\n            if (pressureBuffer.getCount() &gt;= 50) {\n                double sum = 0;\n                for (int i = 0; i &lt; 50; i++) {\n                    sum += pressureBuffer[i];\n                }\n                groundPressure = sum / 50.0;\n                calibrated = true;\n\n                LOGI(\"Ground pressure: %.2f Pa\", groundPressure);\n            }\n        }\n\n        return true;\n    }\n};\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#velocity-estimation-from-position","title":"Velocity Estimation from Position","text":"<p>Calculate velocity using recent position history:</p> <pre><code>struct PositionTimestamp {\n    Vector&lt;3&gt; position;\n    double timestamp;\n};\n\nCircBuffer&lt;PositionTimestamp&gt; posHistory(10);\n\nVector&lt;3&gt; estimateVelocity() {\n    if (posHistory.getCount() &lt; 2) {\n        return Vector&lt;3&gt;(0, 0, 0);\n    }\n\n    // Use oldest and newest positions\n    PositionTimestamp oldest = posHistory[0];\n    PositionTimestamp newest = posHistory[posHistory.getCount() - 1];\n\n    double dt = newest.timestamp - oldest.timestamp;\n    if (dt &lt; 0.001) return Vector&lt;3&gt;(0, 0, 0);\n\n    Vector&lt;3&gt; displacement = newest.position - oldest.position;\n    return displacement / dt;\n}\n\nvoid loop() {\n    PositionTimestamp pt;\n    pt.position = state.getPosition();\n    pt.timestamp = millis() / 1000.0;\n\n    posHistory.push(pt);\n\n    Vector&lt;3&gt; velocity = estimateVelocity();\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#peak-detection","title":"Peak Detection","text":"<p>Detect local maxima in sensor data:</p> <pre><code>CircBuffer&lt;double&gt; altitudeBuffer(20);\n\nbool detectApogee() {\n    if (altitudeBuffer.getCount() &lt; 20) return false;\n\n    // Check if middle element is a local maximum\n    double center = altitudeBuffer[10];\n\n    // Check all before are lower\n    for (int i = 0; i &lt; 10; i++) {\n        if (altitudeBuffer[i] &gt;= center) return false;\n    }\n\n    // Check all after are lower\n    for (int i = 11; i &lt; 20; i++) {\n        if (altitudeBuffer[i] &gt;= center) return false;\n    }\n\n    return true;  // Center is a local maximum\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#outlier-rejection","title":"Outlier Rejection","text":"<p>Reject sensor readings that deviate significantly from recent history:</p> <pre><code>CircBuffer&lt;double&gt; gyroBuffer(50);\n\nbool isOutlier(double newReading, double threshold = 3.0) {\n    if (gyroBuffer.getCount() &lt; 10) return false;\n\n    // Calculate mean\n    double sum = 0;\n    int count = gyroBuffer.getCount();\n    for (int i = 0; i &lt; count; i++) {\n        sum += gyroBuffer[i];\n    }\n    double mean = sum / count;\n\n    // Calculate standard deviation\n    double sqSum = 0;\n    for (int i = 0; i &lt; count; i++) {\n        double diff = gyroBuffer[i] - mean;\n        sqSum += diff * diff;\n    }\n    double stdDev = sqrt(sqSum / count);\n\n    // Check if reading is beyond threshold\n    return abs(newReading - mean) &gt; (threshold * stdDev);\n}\n\nvoid loop() {\n    double gyroX = imu.getGyroscopeGlobal().x();\n\n    if (!isOutlier(gyroX)) {\n        gyroBuffer.push(gyroX);\n        // Use reading\n    } else {\n        LOGW(\"Gyro outlier rejected: %.2f\", gyroX);\n    }\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#integration-with-sensors","title":"Integration with Sensors","text":"<p>Many sensor classes use <code>CircBuffer</code> internally for calibration and filtering. You can access these patterns in custom sensor implementations:</p> <pre><code>class SmartBarometer : public Barometer {\nprivate:\n    static const int BUFFER_SIZE = 100;\n    static const int CALIBRATION_SAMPLES = 50;\n\n    CircBuffer&lt;double&gt; pressureBuffer{BUFFER_SIZE};\n    bool calibrated = false;\n\nprotected:\n    bool read() override {\n        pressure = hardware.readPressure();\n        pressureBuffer.push(pressure);\n\n        if (!calibrated &amp;&amp; pressureBuffer.getCount() &gt;= CALIBRATION_SAMPLES) {\n            calibrateGround();\n        }\n\n        return true;\n    }\n\nprivate:\n    void calibrateGround() {\n        double sum = 0;\n\n        // Use only first half to avoid launch transients\n        for (int i = 0; i &lt; CALIBRATION_SAMPLES; i++) {\n            sum += pressureBuffer[i];\n        }\n\n        double groundPressure = sum / CALIBRATION_SAMPLES;\n        altitudeASL = calcAltitude(groundPressure);\n        calibrated = true;\n\n        LOGI(\"Ground altitude calibrated: %.2f m\", altitudeASL);\n    }\n};\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#copy-semantics","title":"Copy Semantics","text":"<p><code>CircBuffer</code> supports both copy construction and copy assignment:</p> <pre><code>CircBuffer&lt;double&gt; buffer1(10);\nbuffer1.push(1.0);\nbuffer1.push(2.0);\n\n// Copy constructor\nCircBuffer&lt;double&gt; buffer2 = buffer1;\n\n// Copy assignment\nCircBuffer&lt;double&gt; buffer3(10);\nbuffer3 = buffer1;\n\n// All three buffers now contain [1.0, 2.0]\n</code></pre> <p>Copies create independent buffers\u2014modifying one doesn't affect the others.</p>"},{"location":"user-guide/utils/circbuffer/#memory-considerations","title":"Memory Considerations","text":"<ul> <li>Fixed allocation: Memory is allocated once during construction and never grows</li> <li>Heap storage: Buffer uses dynamic allocation internally (<code>new T[size]</code>)</li> <li>Copy overhead: Copying a buffer allocates new memory and copies all elements</li> <li>Template instantiation: Each <code>CircBuffer&lt;T&gt;</code> type creates a separate class</li> </ul> <p>Memory usage: <pre><code>Bytes = sizeof(T) * size + overhead\n</code></pre></p> <p>For example: - <code>CircBuffer&lt;double&gt;(100)</code> \u2248 800 bytes (8 bytes/double \u00d7 100) - <code>CircBuffer&lt;Vector&lt;3&gt;&gt;(50)</code> \u2248 1200 bytes (24 bytes/vector \u00d7 50)</p>"},{"location":"user-guide/utils/circbuffer/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Size buffers appropriately: Larger buffers provide better filtering but consume more memory. Typical sizes: 20-200 elements.</p> </li> <li> <p>Check before accessing: Always verify count before array access:    <pre><code>if (buffer.getCount() &gt; 0) {\n    double val = buffer[0];\n}\n</code></pre></p> </li> <li> <p>Avoid frequent copies: Copying large buffers is expensive. Pass by reference when possible:    <pre><code>void processBuffer(const CircBuffer&lt;double&gt;&amp; buffer) {\n    // Use buffer without copying\n}\n</code></pre></p> </li> <li> <p>Clear on reset: Clear buffers when transitioning stages to avoid stale data:    <pre><code>if (stageChanged) {\n    gyroBuffer.clear();\n}\n</code></pre></p> </li> <li> <p>Use const access: Use the const <code>operator[]</code> for read-only access to enable compiler optimizations.</p> </li> <li> <p>Calibration patterns: Collect buffer data during stable periods (pre-launch, steady flight) for reliable baselines.</p> </li> </ol>"},{"location":"user-guide/utils/circbuffer/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/utils/circbuffer/#exponential-moving-average","title":"Exponential Moving Average","text":"<pre><code>double ema = 0;\ndouble alpha = 0.1;\n\nvoid loop() {\n    double reading = sensor.read();\n    ema = alpha * reading + (1 - alpha) * ema;\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#median-filter","title":"Median Filter","text":"<pre><code>CircBuffer&lt;double&gt; buffer(9);\n\ndouble getMedian() {\n    if (buffer.getCount() &lt; 9) return 0;\n\n    double sorted[9];\n    for (int i = 0; i &lt; 9; i++) {\n        sorted[i] = buffer[i];\n    }\n\n    // Simple bubble sort\n    for (int i = 0; i &lt; 8; i++) {\n        for (int j = 0; j &lt; 8 - i; j++) {\n            if (sorted[j] &gt; sorted[j + 1]) {\n                double tmp = sorted[j];\n                sorted[j] = sorted[j + 1];\n                sorted[j + 1] = tmp;\n            }\n        }\n    }\n\n    return sorted[4];  // Middle element\n}\n</code></pre>"},{"location":"user-guide/utils/circbuffer/#limitations","title":"Limitations","text":"<ul> <li>Fixed size: Cannot grow or shrink after construction</li> <li>No bounds checking in release: Array access via <code>[]</code> doesn't validate indices in production builds</li> <li>Overwrites on full: Pushing to a full buffer silently overwrites oldest data</li> <li>No iterators: No STL-style iterators; use index-based loops instead</li> </ul>"},{"location":"user-guide/utils/circbuffer/#summary","title":"Summary","text":"<ul> <li><code>CircBuffer</code> provides fixed-size FIFO queue with random access</li> <li>Ideal for moving averages, calibration, and filtering</li> <li>Automatically overwrites oldest data when full</li> <li>Supports both queue operations (push/pop) and array access (<code>[]</code>)</li> <li>Templated for any data type</li> <li>Fixed memory allocation\u2014size set at construction</li> </ul> <p>For examples of <code>CircBuffer</code> in real sensors, see the barometer implementation on GitHub: <code>https://github.com/Terrapin-Rocket-Team/Astra/blob/main/src/Sensors/Baro/Barometer.cpp</code></p>"},{"location":"user-guide/utils/logger/","title":"Logging System","text":"<p>Astra has two independent logging channels:</p> <ul> <li>EventLogger \u2192 human-readable status (<code>LOG/</code> prefix when enabled)</li> <li>DataLogger \u2192 CSV telemetry (<code>TELEM/</code> prefix when enabled)</li> </ul> <p>Both log through <code>ILogSink</code> backends.</p>"},{"location":"user-guide/utils/logger/#eventlogger-log","title":"EventLogger (LOG/)","text":""},{"location":"user-guide/utils/logger/#configure","title":"Configure","text":"<pre><code>#include &lt;RecordData/Logging/EventLogger.h&gt;\n#include &lt;RecordData/Logging/LoggingBackend/ILogSink.h&gt;\n\nUARTLog eventLog(Serial, 115200, true);\nILogSink* eventSinks[] = { &amp;eventLog };\n\nvoid setup() {\n    EventLogger::configure(eventSinks, 1);\n}\n</code></pre> <p>Alternatively, pass the same sinks to <code>AstraConfig.withEventLogs()</code> and let Astra configure it during <code>init()</code>.</p>"},{"location":"user-guide/utils/logger/#use","title":"Use","text":"<pre><code>LOGI(\"System initialized\");\nLOGW(\"GPS fix lost\");\nLOGE(\"Barometer init failed\");\n</code></pre>"},{"location":"user-guide/utils/logger/#datalogger-telem","title":"DataLogger (TELEM/)","text":"<p><code>DataLogger</code> writes CSV telemetry from every <code>DataReporter</code>. Sensors and <code>State</code> register automatically.</p>"},{"location":"user-guide/utils/logger/#configure-via-astraconfig","title":"Configure via AstraConfig","text":"<pre><code>FileLogSink telemFile(\"TELEM.csv\", StorageBackend::SD_CARD, true);\nILogSink* telemSinks[] = { &amp;telemFile };\n\nAstraConfig config = AstraConfig()\n    .withState(&amp;state)\n    .withDataLogs(telemSinks, 1);\n</code></pre>"},{"location":"user-guide/utils/logger/#header-timing","title":"Header Timing","text":"<p>The telemetry header is written once at logger initialization. Ensure all <code>DataReporter</code>s are constructed before <code>Astra::init()</code> (or before <code>DataLogger::configure()</code> if used directly).</p>"},{"location":"user-guide/utils/logger/#ilogsink-backends","title":"ILogSink Backends","text":""},{"location":"user-guide/utils/logger/#uartlog-usblog","title":"UARTLog / USBLog","text":"<pre><code>UARTLog log1(Serial1, 115200, true);\nUSBLog log2(Serial, 115200, true);\n</code></pre>"},{"location":"user-guide/utils/logger/#printlog","title":"PrintLog","text":"<pre><code>PrintLog log(myPrint, true);\n</code></pre>"},{"location":"user-guide/utils/logger/#circbufferlog","title":"CircBufferLog","text":"<pre><code>CircBufferLog buf(5000, true);\n</code></pre> <p><code>CircBufferLog::transfer()</code> can flush buffered data into another sink later.</p>"},{"location":"user-guide/utils/logger/#filelogsink","title":"FileLogSink","text":"<pre><code>FileLogSink log(\"TELEM.csv\", StorageBackend::SD_CARD, true);\n</code></pre> <p><code>FileLogSink</code> automatically finds a unique filename:</p> <pre><code>TELEM.csv\nTELEM_1.csv\nTELEM_2.csv\n</code></pre>"},{"location":"user-guide/utils/logger/#storage-backends","title":"Storage Backends","text":"<p>The storage backend enum is platform-specific:</p> Platform StorageBackend values STM32 <code>EMMC</code>, <code>SD_CARD</code> ESP32 <code>SD_CARD</code> Teensy <code>SD_CARD</code> Native <code>NONE</code> <p>See <code>IStorage</code> and <code>StorageFactory</code> for backend details.</p>"},{"location":"user-guide/utils/logger/#prefixes","title":"Prefixes","text":"<p>If <code>wantsPrefix()</code> is enabled on a sink:</p> <ul> <li><code>EventLogger</code> writes <code>LOG/</code></li> <li><code>DataLogger</code> writes <code>TELEM/</code></li> </ul> <p>This is useful when multiplexing over a shared serial link.</p>"},{"location":"user-guide/utils/logger/#reconfiguring-loggers","title":"Reconfiguring Loggers","text":"<p>You can reconfigure loggers at runtime if a new sink becomes available:</p> <pre><code>EventLogger::configure(newEventSinks, count);\nDataLogger::configure(newDataSinks, count);\n</code></pre> <p>This is useful for plug\u2011in devices (e.g., a ground station that connects after boot).</p>"},{"location":"user-guide/utils/math/","title":"Math","text":"<p>Astra provides three mathematical classes for vector and matrix operations: <code>Vector</code>, <code>Matrix</code>, and <code>Quaternion</code>. These are used throughout the library for sensor data representation, coordinate transformations, and state estimation.</p>"},{"location":"user-guide/utils/math/#vector","title":"Vector","text":"<p>The <code>Vector</code> class represents a fixed-size mathematical vector (not to be confused with <code>std::vector</code>). It supports standard vector operations and is templated on size.</p>"},{"location":"user-guide/utils/math/#overview","title":"Overview","text":"<p><code>Vector&lt;N&gt;</code> stores <code>N</code> double values and provides operations like addition, subtraction, dot products, cross products, and normalization. Adapted from Adafruit's IMU vector class.</p> <p>Common sizes: - <code>Vector&lt;2&gt;</code> - 2D coordinates (latitude/longitude, horizontal position) - <code>Vector&lt;3&gt;</code> - 3D coordinates (position, velocity, acceleration, orientation) - <code>Vector&lt;4&gt;</code> - Quaternion components, homogeneous coordinates</p>"},{"location":"user-guide/utils/math/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;Math/Vector.h&gt;\n\nusing namespace astra;\n\n// Create vectors\nVector&lt;3&gt; v1(1.0, 2.0, 3.0);\nVector&lt;3&gt; v2(4.0, 5.0, 6.0);\n\n// Access components\ndouble x = v1.x();  // 1.0\ndouble y = v1.y();  // 2.0\ndouble z = v1.z();  // 3.0\n\n// Array-style access\ndouble val = v1[0];  // 1.0 (same as x())\nv1[1] = 7.0;         // Set y to 7.0\n</code></pre>"},{"location":"user-guide/utils/math/#vector-operations","title":"Vector Operations","text":"<p>Arithmetic:</p> <pre><code>Vector&lt;3&gt; a(1.0, 2.0, 3.0);\nVector&lt;3&gt; b(4.0, 5.0, 6.0);\n\nVector&lt;3&gt; sum = a + b;           // (5.0, 7.0, 9.0)\nVector&lt;3&gt; diff = a - b;          // (-3.0, -3.0, -3.0)\nVector&lt;3&gt; scaled = a * 2.0;      // (2.0, 4.0, 6.0)\nVector&lt;3&gt; divided = a / 2.0;     // (0.5, 1.0, 1.5)\n\n// In-place operations\na += b;  // a becomes (5.0, 7.0, 9.0)\n</code></pre> <p>Vector Products:</p> <pre><code>Vector&lt;3&gt; a(1.0, 0.0, 0.0);\nVector&lt;3&gt; b(0.0, 1.0, 0.0);\n\n// Dot product (scalar result)\ndouble dot = a.dot(b);           // 0.0\n\n// Cross product (3D only, vector result)\nVector&lt;3&gt; cross = a.cross(b);    // (0.0, 0.0, 1.0)\n</code></pre> <p>Magnitude and Normalization:</p> <pre><code>Vector&lt;3&gt; v(3.0, 4.0, 0.0);\n\ndouble mag = v.magnitude();      // 5.0\n\nv.normalize();                   // v becomes (0.6, 0.8, 0.0)\ndouble newMag = v.magnitude();   // 1.0\n</code></pre> <p>Utility Methods:</p> <pre><code>Vector&lt;3&gt; v(1.0, 2.0, 3.0);\n\nVector&lt;3&gt; inverted = v.invert(); // (-1.0, -2.0, -3.0)\nVector&lt;3&gt; scaled = v.scale(2.5); // (2.5, 5.0, 7.5)\n\n// Angle conversions\nv.toRadians();                   // Convert degrees to radians\nv.toDegrees();                   // Convert radians to degrees\n\n// Size query\nuint8_t size = v.n();            // 3\n</code></pre>"},{"location":"user-guide/utils/math/#practical-examples","title":"Practical Examples","text":"<p>Position displacement:</p> <pre><code>Vector&lt;3&gt; startPos = state.getPosition();   // capture at t0\nVector&lt;3&gt; currentPos = state.getPosition(); // later in time\n\nVector&lt;3&gt; displacement = currentPos - startPos;\ndouble distance = displacement.magnitude();\n\nLOGI(\"Traveled %.2f meters\", distance);\n</code></pre> <p>Velocity from acceleration:</p> <pre><code>Vector&lt;3&gt; velocity(0, 0, 0);\nVector&lt;3&gt; acceleration = state.getAcceleration(); // ENU linear accel\ndouble dt = 0.01;  // 10ms\n\nvelocity += acceleration * dt;\n</code></pre> <p>Unit direction vectors:</p> <pre><code>Vector&lt;3&gt; direction(1.0, 1.0, 0.0);\ndirection.normalize();  // (0.707, 0.707, 0.0)\n\n// Use as unit direction\nVector&lt;3&gt; target = position + direction * 10.0;  // 10 meters in that direction\n</code></pre> <p>Angle between vectors:</p> <pre><code>Vector&lt;3&gt; v1(1.0, 0.0, 0.0);\nVector&lt;3&gt; v2(0.0, 1.0, 0.0);\n\ndouble cosAngle = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\ndouble angleRad = acos(cosAngle);\ndouble angleDeg = angleRad * 57.2957795;  // 90 degrees\n</code></pre>"},{"location":"user-guide/utils/math/#matrix","title":"Matrix","text":"<p>The <code>Matrix</code> class provides dense matrix operations for Kalman filters and linear algebra. It supports basic operations like addition, subtraction, multiplication, transposition, and inversion.</p>"},{"location":"user-guide/utils/math/#overview_1","title":"Overview","text":"<p>Matrix operations use dynamically allocated arrays. Matrices are passed ownership of their data arrays (shallow copy), so arrays must be heap-allocated and should not be modified or deleted after passing to the constructor.</p>"},{"location":"user-guide/utils/math/#basic-usage_1","title":"Basic Usage","text":"<pre><code>#include &lt;Math/Matrix.h&gt;\n\nusing namespace astra;\n\n// Create 3x3 identity matrix\ndouble* data = new double[9]{\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n};\n\nMatrix m(3, 3, data);\n\n// Access elements (row, col)\ndouble val = m(0, 0);    // 1.0\nm(1, 2) = 5.0;           // Set element at row 1, col 2\n\n// Query dimensions\nuint8_t rows = m.getRows();  // 3\nuint8_t cols = m.getCols();  // 3\n</code></pre> <p>Memory Management</p> <p>The <code>Matrix</code> class takes ownership of the array passed to its constructor: - The array must be heap-allocated (<code>new double[]</code>) - Do not modify or delete the array after passing it to <code>Matrix</code> - The array is automatically deleted when the matrix is destroyed - Shallow copy only\u2014matrix operations create new arrays as needed</p>"},{"location":"user-guide/utils/math/#matrix-operations","title":"Matrix Operations","text":"<p>Arithmetic:</p> <pre><code>Matrix A(3, 3, dataA);\nMatrix B(3, 3, dataB);\n\nMatrix C = A + B;        // Addition\nMatrix D = A - B;        // Subtraction\nMatrix E = A * B;        // Matrix multiplication\nMatrix F = A * 2.0;      // Scalar multiplication\n</code></pre> <p>Transpose and Inverse:</p> <pre><code>Matrix A(3, 3, data);\n\nMatrix AT = A.T();           // Transpose\nMatrix AT_alt = A.transpose(); // Same as T()\n\nMatrix Ainv = A.inv();       // Inverse\nMatrix Ainv_alt = A.inverse(); // Same as inv()\n</code></pre> <p>Special Matrices:</p> <pre><code>// Identity matrix\nMatrix I = Matrix::ident(3);  // 3x3 identity\n\n// Trace (sum of diagonal elements)\ndouble tr = A.trace();\n</code></pre> <p>Display:</p> <pre><code>Matrix A(3, 3, data);\nA.disp();  // Print to serial/console\n</code></pre>"},{"location":"user-guide/utils/math/#practical-examples_1","title":"Practical Examples","text":"<p>Kalman Filter State Transition:</p> <pre><code>// State transition matrix (constant velocity model)\ndouble* F_data = new double[9]{\n    1.0, dt, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0\n};\nMatrix F(3, 3, F_data);\n\n// Previous state\ndouble* x_data = new double[3]{position, velocity, 1.0};\nMatrix x(3, 1, x_data);\n\n// Predict new state\nMatrix x_pred = F * x;\n</code></pre> <p>Covariance Update:</p> <pre><code>Matrix P = covariance;\nMatrix Q = processNoise;\n\n// Predict covariance: P' = F*P*F^T + Q\nMatrix P_pred = F * P * F.transpose() + Q;\n</code></pre> <p>Measurement Update:</p> <pre><code>// Kalman gain: K = P*H^T * (H*P*H^T + R)^-1\nMatrix K = P * H.transpose() * (H * P * H.transpose() + R).inverse();\n\n// State update: x = x + K*y\nMatrix x_new = x + K * innovation;\n\n// Covariance update: P = (I - K*H) * P\nMatrix I = Matrix::ident(stateSize);\nMatrix P_new = (I - K * H) * P;\n</code></pre>"},{"location":"user-guide/utils/math/#quaternion","title":"Quaternion","text":"<p>The <code>Quaternion</code> class represents 3D rotations using quaternion algebra. It's more stable than Euler angles and avoids gimbal lock. Adapted from Adafruit's BNO055 library.</p>"},{"location":"user-guide/utils/math/#overview_2","title":"Overview","text":"<p>Quaternions store rotation as four components: <code>w</code> (scalar) and <code>x, y, z</code> (vector). They provide efficient composition, interpolation, and conversion to/from other rotation representations.</p> <p>Common uses: - IMU orientation representation - Coordinate frame transformations - Smooth rotation interpolation</p>"},{"location":"user-guide/utils/math/#basic-usage_2","title":"Basic Usage","text":"<pre><code>#include &lt;Math/Quaternion.h&gt;\n\nusing namespace astra;\n\n// Identity quaternion (no rotation)\nQuaternion q;  // (w=1, x=0, y=0, z=0)\n\n// Create from components\nQuaternion q1(1.0, 0.0, 0.0, 0.0);\n\n// Create from scalar + vector\nVector&lt;3&gt; axis(0.0, 0.0, 1.0);\nQuaternion q2(0.707, axis * 0.707);\n\n// Access components\ndouble w = q.w();\ndouble x = q.x();\ndouble y = q.y();\ndouble z = q.z();\n</code></pre>"},{"location":"user-guide/utils/math/#quaternion-operations","title":"Quaternion Operations","text":"<p>Basic Operations:</p> <pre><code>Quaternion q1(1.0, 0.0, 0.0, 0.0);\nQuaternion q2(0.707, 0.0, 0.0, 0.707);\n\n// Quaternion multiplication (rotation composition)\nQuaternion q3 = q1 * q2;\n\n// Addition/subtraction\nQuaternion sum = q1 + q2;\nQuaternion diff = q1 - q2;\n\n// Scalar operations\nQuaternion scaled = q1 * 2.0;\nQuaternion divided = q1 / 2.0;\n\n// Conjugate (inverse rotation for unit quaternions)\nQuaternion conj = q.conjugate();\n</code></pre> <p>Normalization:</p> <pre><code>Quaternion q(1.0, 2.0, 3.0, 4.0);\n\ndouble mag = q.magnitude();  // sqrt(1^2 + 2^2 + 3^2 + 4^2) = 5.477\nq.normalize();               // Unit quaternion\n</code></pre>"},{"location":"user-guide/utils/math/#rotation-representations","title":"Rotation Representations","text":"<p>From Axis-Angle:</p> <pre><code>Quaternion q;\nVector&lt;3&gt; axis(0.0, 0.0, 1.0);  // Z-axis\ndouble angle = M_PI / 2;         // 90 degrees\n\nq.fromAxisAngle(axis, angle);\n</code></pre> <p>To Axis-Angle:</p> <pre><code>Vector&lt;3&gt; axis;\ndouble angle;\n\nq.toAxisAngle(axis, angle);\nLOGI(\"Rotation: %.2f rad about (%.2f, %.2f, %.2f)\",\n     angle, axis.x(), axis.y(), axis.z());\n</code></pre> <p>From Rotation Matrix:</p> <pre><code>Matrix R(3, 3, rotationMatrixData);\nQuaternion q;\nq.fromMatrix(R);\n</code></pre> <p>To Rotation Matrix:</p> <pre><code>Matrix R = q.toMatrix();  // 3x3 Direction Cosine Matrix\n</code></pre> <p>To Euler Angles (Yaw-Pitch-Roll):</p> <pre><code>Vector&lt;3&gt; euler = q.toEuler321();\n\ndouble yaw = euler[0];    // Rotation about Z\ndouble pitch = euler[1];  // Rotation about Y\ndouble roll = euler[2];   // Rotation about X\n\n// Convert to degrees\neuler.toDegrees();\nLOGI(\"Orientation: yaw=%.1f, pitch=%.1f, roll=%.1f\",\n     euler[0], euler[1], euler[2]);\n</code></pre>"},{"location":"user-guide/utils/math/#rotating-vectors","title":"Rotating Vectors","text":"<p>Apply rotation to a vector:</p> <pre><code>Quaternion orientation = state.getOrientation();\nVector&lt;3&gt; localAccel(0.0, 0.0, 9.81);  // Gravity in body frame\n\n// Rotate to global frame\nVector&lt;3&gt; globalAccel = orientation.rotateVector(localAccel);\n</code></pre>"},{"location":"user-guide/utils/math/#interpolation","title":"Interpolation","text":"<p>Smoothly interpolate between orientations:</p> <pre><code>Quaternion current = state.getOrientation();\nQuaternion identity(1.0, 0.0, 0.0, 0.0);\n\ndouble alpha = 0.9;  // Weighting (0 = identity, 1 = current)\n\n// SLERP/LERP interpolation\nQuaternion smoothed = current.interpolation(identity, alpha);\n</code></pre> <p>Parameters: - <code>q</code> - Target quaternion to interpolate toward - <code>alpha</code> - Weight (0-1): higher = closer to current quaternion - <code>epsilon</code> - Threshold (default 0.9): below uses SLERP, above uses LERP</p>"},{"location":"user-guide/utils/math/#practical-examples_2","title":"Practical Examples","text":"<p>IMU Orientation:</p> <pre><code>Quaternion orientation = state.getOrientation();\nVector&lt;3&gt; euler = orientation.toEuler321();\neuler.toDegrees();\n\nLOGI(\"Yaw: %.1f, Pitch: %.1f, Roll: %.1f\",\n     euler.x(), euler.y(), euler.z());\n</code></pre> <p>Transform Sensor Readings to Global Frame:</p> <pre><code>// Acceleration in body frame\nVector&lt;3&gt; accelBody = imu.getAccel();  // body-frame accel (m/s^2)\n\n// Orientation of body relative to global\nQuaternion orientation = state.getOrientation();\n\n// Transform to global frame\nVector&lt;3&gt; accelGlobal = orientation.rotateVector(accelBody);\n</code></pre> <p>Composing Rotations:</p> <pre><code>// Rotate 90\u00b0 about Z, then 45\u00b0 about X\nQuaternion rotZ, rotX;\nrotZ.fromAxisAngle(Vector&lt;3&gt;(0, 0, 1), M_PI / 2);\nrotX.fromAxisAngle(Vector&lt;3&gt;(1, 0, 0), M_PI / 4);\n\n// Combined rotation (order matters!)\nQuaternion combined = rotZ * rotX;\n</code></pre> <p>Orientation Rate (Angular Velocity):</p> <pre><code>Quaternion orientation = state.getOrientation();\ndouble dt = 0.01;  // 10ms\n\nVector&lt;3&gt; angularVel = orientation.toAngularVelocity(dt);\nLOGI(\"Angular rates: %.2f, %.2f, %.2f rad/s\",\n     angularVel.x(), angularVel.y(), angularVel.z());\n</code></pre>"},{"location":"user-guide/utils/math/#integration-with-astra","title":"Integration with Astra","text":"<p>These math classes are used throughout Astra's sensor and state systems:</p> <p>Sensors: <pre><code>Vector&lt;3&gt; accelBody = imu.getAccel();\nVector&lt;3&gt; positionLLA = gps.getPos();\n</code></pre></p> <p>State: <pre><code>Vector&lt;3&gt; velocity = state.getVelocity();\nVector&lt;3&gt; acceleration = state.getAcceleration();\nQuaternion orientation = state.getOrientation();\n</code></pre></p> <p>Filters: <pre><code>class MyKalmanFilter : public LinearKalmanFilter {\n    Matrix F;  // State transition\n    Matrix H;  // Measurement model\n    Matrix Q;  // Process noise\n    Matrix R;  // Measurement noise\n    // ...\n};\n</code></pre></p>"},{"location":"user-guide/utils/math/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use stack allocation for Vectors: Vectors are lightweight and can be allocated on the stack.</p> </li> <li> <p>Heap-allocate Matrix data: Always use <code>new double[]</code> for matrix arrays:    <pre><code>double* data = new double[9]{...};\nMatrix m(3, 3, data);\n</code></pre></p> </li> <li> <p>Normalize quaternions regularly: Floating-point errors accumulate:    <pre><code>orientation.normalize();  // Maintain unit magnitude\n</code></pre></p> </li> <li> <p>Prefer quaternions for rotations: More stable than Euler angles, no gimbal lock.</p> </li> <li> <p>Check vector magnitude before normalization: Avoid division by zero:    <pre><code>double mag = v.magnitude();\nif (mag &gt; 1e-6) {\n    v.normalize();\n}\n</code></pre></p> </li> <li> <p>Use matrix inversion carefully: Inversion is expensive and can fail for singular matrices.</p> </li> </ol>"},{"location":"user-guide/utils/math/#limitations","title":"Limitations","text":"<p>Vector: - Fixed size at compile time - Cross product only defined for 3D vectors</p> <p>Matrix: - Shallow copy of data array (ownership transfer) - Dense matrices only (no sparse matrix support) - Limited to 255\u00d7255 size (uses <code>uint8_t</code> for dimensions) - Matrix inversion uses LU decomposition (expensive for large matrices)</p> <p>Quaternion: - Quaternion multiplication is non-commutative (order matters) - Floating-point drift requires periodic normalization - Euler angle conversion has gimbal lock at \u00b190\u00b0 pitch</p>"},{"location":"user-guide/utils/math/#summary","title":"Summary","text":"<ul> <li>Vector: Fixed-size vector for 2D/3D math, supports arithmetic and products</li> <li>Matrix: Dense matrix for linear algebra, used in Kalman filters</li> <li>Quaternion: Rotation representation, preferred for 3D orientation</li> <li>All classes adapted from proven libraries (Adafruit IMU)</li> <li>Integrated throughout Astra's sensor and state systems</li> </ul> <p>For usage in state estimation, see the Filter and State documentation.</p>"},{"location":"user-guide/utils/mmfssys/","title":"Astra System","text":"<p><code>Astra</code> is the high-level orchestrator. It wires sensors, state estimation, logging, and indicators into a single update loop.</p>"},{"location":"user-guide/utils/mmfssys/#minimal-setup","title":"Minimal Setup","text":"<pre><code>#include &lt;Utils/Astra.h&gt;\n#include &lt;State/DefaultState.h&gt;\n#include &lt;Sensors/HW/IMU/BMI088.h&gt;\n#include &lt;Sensors/HW/Baro/DPS368.h&gt;\n#include &lt;Sensors/HW/GPS/MAX_M10S.h&gt;\n\nusing namespace astra;\n\nBMI088 imu;\nDPS368 baro;\nMAX_M10S gps;\nDefaultState state;\n\nAstraConfig config = AstraConfig()\n    .with6DoFIMU(&amp;imu)\n    .withBaro(&amp;baro)\n    .withGPS(&amp;gps)\n    .withState(&amp;state);  // Optional: Astra will use DefaultState if not provided\n\nAstra sys(&amp;config);\n</code></pre> <p>Call <code>sys.init()</code> in <code>setup()</code> and <code>sys.update()</code> in <code>loop()</code>.</p>"},{"location":"user-guide/utils/mmfssys/#astraconfig-overview","title":"AstraConfig Overview","text":""},{"location":"user-guide/utils/mmfssys/#required","title":"Required","text":"<p><code>withState(State* state)</code></p> <p>Provide a <code>State</code> (or <code>DefaultState</code>). Astra uses it for orientation and position estimation.</p>"},{"location":"user-guide/utils/mmfssys/#sensor-configuration","title":"Sensor Configuration","text":"<p>Provide sensors directly:</p> <ul> <li><code>withAccel(Accel*)</code></li> <li><code>withGyro(Gyro*)</code></li> <li><code>withMag(Mag*)</code></li> <li><code>withBaro(Barometer*)</code></li> <li><code>withGPS(GPS*)</code></li> <li><code>withMiscSensor(Sensor*)</code> (logged, not used for state)</li> </ul> <p>Convenience for IMUs:</p> <ul> <li><code>with6DoFIMU(IMU6DoF*)</code> \u2013 extracts accel + gyro</li> <li><code>with9DoFIMU(IMU9DoF*)</code> \u2013 extracts accel + gyro + mag</li> </ul> <p>The IMU itself is added as a misc sensor for logging.</p>"},{"location":"user-guide/utils/mmfssys/#logging-sinks","title":"Logging Sinks","text":"<p><code>withDataLogs(ILogSink** sinks, uint8_t count)</code></p> <p>Configures telemetry CSV sinks for <code>DataLogger</code>. Event logs are configured separately via <code>EventLogger::configure()</code>.</p> <p><code>withEventLogs(ILogSink** sinks, uint8_t count)</code></p> <p>Configures sinks for <code>EventLogger</code> during <code>Astra::init()</code>.</p>"},{"location":"user-guide/utils/mmfssys/#logging-cadence","title":"Logging Cadence","text":"<pre><code>config.withLoggingRate(20);      // Hz\nconfig.withLoggingInterval(50);  // ms\n</code></pre> <p><code>Astra</code> evaluates logging on a seconds-based clock. Use <code>withLoggingInterval()</code> if you want an explicit interval.</p>"},{"location":"user-guide/utils/mmfssys/#blinkbuzz","title":"BlinkBuzz","text":"<ul> <li><code>withBuzzerPin(uint)</code> \u2013 sets global <code>BUZZER</code> and registers pin</li> <li><code>withBBPin(uint)</code> \u2013 registers a pin</li> <li><code>withBBAsync(bool enable, uint queueSize = 50)</code></li> </ul>"},{"location":"user-guide/utils/mmfssys/#status-indicators","title":"Status Indicators","text":"<p>Optional diagnostic LEDs/buzzers:</p> <ul> <li><code>withStatusLED(int pin)</code></li> <li><code>withStatusBuzzer(int pin)</code></li> <li><code>withGPSFixLED(int pin)</code></li> </ul> <p>Init feedback patterns:</p> <ul> <li>Solid ON = all sensors initialized</li> <li>N blinks = single sensor failure (1=Accel, 2=Gyro, 3=Mag, 4=Baro, 5=GPS, 6=Misc)</li> <li>Rapid blink = multiple failures</li> </ul>"},{"location":"user-guide/utils/mmfssys/#hitl-mode","title":"HITL Mode","text":"<p><code>withHITL(bool enabled)</code></p> <p>Flags the system as HITL. Use this when you pass simulation time into <code>update(simTimeSeconds)</code>.</p>"},{"location":"user-guide/utils/mmfssys/#ownership-model","title":"Ownership Model","text":"<ul> <li><code>Astra</code> stores a pointer to <code>AstraConfig</code>. Ensure the config outlives the <code>Astra</code> instance.</li> <li><code>Astra</code> does not own sensors or log sinks. You are responsible for their lifetime.</li> <li>If you call <code>withState()</code>, you own that <code>State</code>.</li> <li>If you do not call <code>withState()</code>, <code>Astra</code> creates a <code>DefaultState</code> and owns it.</li> <li><code>SerialMessageRouter</code> is created and owned by <code>Astra</code>.</li> </ul>"},{"location":"user-guide/utils/mmfssys/#astra-api","title":"Astra API","text":""},{"location":"user-guide/utils/mmfssys/#int-init","title":"<code>int init()</code>","text":"<p>Initializes BlinkBuzz, logging sinks, sensors, and state.</p> <p>Returns the number of sensor initialization failures (0 = success).</p>"},{"location":"user-guide/utils/mmfssys/#bool-updatedouble-timeseconds-1","title":"<code>bool update(double timeSeconds = -1)</code>","text":"<p>Runs one system cycle:</p> <ul> <li>Updates <code>SerialMessageRouter</code></li> <li>Updates BlinkBuzz</li> <li>Updates sensors (as each sensor\u2019s update interval allows)</li> <li>Updates orientation + Kalman prediction</li> <li>Updates measurement corrections (GPS/baro)</li> <li>Logs telemetry at the configured logging interval</li> </ul> <p>If <code>timeSeconds</code> is <code>-1</code>, Astra uses <code>millis()/1000.0</code>.</p>"},{"location":"user-guide/utils/mmfssys/#serialmessagerouter-integration","title":"SerialMessageRouter Integration","text":"<p>Astra creates a <code>SerialMessageRouter</code> internally and registers:</p> <pre><code>CMD/HEADER\n</code></pre> <p>Sending <code>CMD/HEADER</code> on a serial interface prints the current telemetry header to that stream.</p> <p>You can access the router to add your own listeners:</p> <pre><code>SerialMessageRouter* router = sys.getMessageRouter();\nrouter-&gt;withListener(\"CMD/\", myHandler);\n</code></pre> <p>Because Astra updates the router internally, you do not need to call <code>router-&gt;update()</code> yourself.</p>"},{"location":"user-guide/utils/mmfssys/#diagnostics-helpers","title":"Diagnostics Helpers","text":"<p><code>Astra</code> exposes flags for debugging:</p> <ul> <li><code>didLog()</code></li> <li><code>didUpdateState()</code></li> <li><code>didPredictState()</code></li> </ul> <p>These are updated each cycle by <code>update()</code>. For per-sensor update events in custom loops or tests, see the Maintainer Guide.</p>"},{"location":"user-guide/utils/serial-router/","title":"SerialMessageRouter","text":"<p><code>SerialMessageRouter</code> centralizes serial parsing and routes messages by prefix.</p>"},{"location":"user-guide/utils/serial-router/#why-use-it","title":"Why Use It?","text":"<ul> <li>Multiple serial interfaces</li> <li>Prefix\u2011based dispatch (<code>HITL/</code>, <code>CMD/</code>, <code>RAD/</code>)</li> <li>Non\u2011blocking, line\u2011buffered operation</li> </ul>"},{"location":"user-guide/utils/serial-router/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;Communication/SerialMessageRouter.h&gt;\n\nusing namespace astra;\n\nSerialMessageRouter router;\n\nvoid handleCmd(const char* msg, const char* prefix, Stream* src) {\n    if (strcmp(msg, \"PING\") == 0) {\n        src-&gt;println(\"PONG\");\n    }\n}\n\nvoid setup() {\n    Serial.begin(115200);\n\n    router.withInterface(&amp;Serial)\n          .withListener(\"CMD/\", handleCmd);\n}\n\nvoid loop() {\n    router.update();  // Non-blocking poll\n}\n</code></pre>"},{"location":"user-guide/utils/serial-router/#callback-signature","title":"Callback Signature","text":"<pre><code>void callback(const char* message,\n              const char* prefix,\n              Stream* source);\n</code></pre> <ul> <li><code>message</code> excludes the prefix</li> <li><code>source</code> is the serial interface that received the message</li> </ul>"},{"location":"user-guide/utils/serial-router/#configuration-options","title":"Configuration Options","text":"<pre><code>SerialMessageRouter router(4, 8, 256);\n\n// 4  = max serial interfaces\n// 8  = max prefix listeners\n// 256 = per-interface line buffer size (bytes)\n\nrouter.withInterface(&amp;Serial)\n      .withListener(\"HITL/\", handleHITL)\n      .withDelimiter('\\n')\n      .withDefaultHandler(handleUnknown);\n</code></pre>"},{"location":"user-guide/utils/serial-router/#astra-integration","title":"Astra Integration","text":"<p><code>Astra</code> creates its own router and listens for:</p> <pre><code>CMD/HEADER\n</code></pre> <p>Use <code>Astra::getMessageRouter()</code> to add more listeners.</p> <p>If you use the full Astra system, you do not need to call <code>router.update()</code> yourself. Astra calls it internally each update cycle.</p>"},{"location":"user-guide/utils/serial-router/#what-the-basic-example-does","title":"What the Basic Example Does","text":"<ul> <li>Registers <code>Serial</code> as an input interface</li> <li>Matches messages that start with <code>CMD/</code></li> <li>Strips the prefix and passes the remainder to <code>handleCmd</code></li> <li>Responds on the same interface (useful for USB vs radio)</li> </ul>"}]}